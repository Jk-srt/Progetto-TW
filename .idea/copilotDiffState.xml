<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env" />
              <option name="originalContent" value="# Database Configuration - PostgreSQL locale in Docker&#10;DATABASE_URL=postgresql://neondb_owner:npg_VATdkwzO94Wr@ep-holy-water-a2lusn2u-pooler.eu-central-1.aws.neon.tech/neondb?sslmode=require&amp;channel_binding=require&#10;&#10;# Database credentials (per riferimento)&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_NAME=taw_flights&#10;DB_USER=taw_user&#10;DB_PASSWORD=taw_password&#10;&#10;# Backend Configuration&#10;NODE_ENV=development&#10;JWT_SECRET=your_jwt_secret_key&#10;PORT=3000&#10;&#10;# Frontend Configuration&#10;ANGULAR_ENV=development&#10;&#10;# Admin account credentials&#10;ADMIN_EMAIL=admin@example.com&#10;ADMIN_PASSWORD=secureTemporaryPwd&#10;" />
              <option name="updatedContent" value="# Database Configuration - PostgreSQL locale in Docker&#10;DATABASE_URL=postgresql://neondb_owner:npg_VATdkwzO94Wr@ep-holy-water-a2lusn2u-pooler.eu-central-1.aws.neon.tech/neondb?sslmode=require&amp;channel_binding=require&#10;&#10;# Database credentials (per riferimento)&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_NAME=taw_flights&#10;DB_USER=taw_user&#10;DB_PASSWORD=taw_password&#10;&#10;# Backend Configuration&#10;NODE_ENV=development&#10;JWT_SECRET=your_jwt_secret_key&#10;PORT=3000&#10;&#10;# Frontend Configuration&#10;ANGULAR_ENV=development&#10;&#10;# Admin account credentials&#10;ADMIN_EMAIL=admin@example.com&#10;ADMIN_PASSWORD=secureTemporaryPwd" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/database-init/init.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/database-init/init.sql" />
              <option name="originalContent" value="-- Creazione database TAW Flights&#10;-- Script di inizializzazione PostgreSQL&#10;&#10;-- Creazione delle tabelle&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    email VARCHAR(255) UNIQUE NOT NULL,&#10;    password_hash VARCHAR(255) NOT NULL,&#10;    first_name VARCHAR(100),&#10;    last_name VARCHAR(100),&#10;    phone VARCHAR(20),&#10;    role VARCHAR(20) NOT NULL DEFAULT 'user',&#10;    airline_id INTEGER REFERENCES airlines(id),&#10;    temporary_password BOOLEAN NOT NULL DEFAULT FALSE,&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE IF NOT EXISTS airports (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(255) NOT NULL,&#10;    iata_code VARCHAR(3) UNIQUE NOT NULL,&#10;    city VARCHAR(100) NOT NULL,&#10;    country VARCHAR(100) NOT NULL,&#10;    latitude DECIMAL(10, 8),&#10;    longitude DECIMAL(11, 8),&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Tabella delle compagnie aeree&#10;CREATE TABLE IF NOT EXISTS airlines (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(255) NOT NULL,&#10;    iata_code VARCHAR(2) UNIQUE NOT NULL,&#10;    icao_code VARCHAR(3) UNIQUE NOT NULL,&#10;    country VARCHAR(100) NOT NULL,&#10;    founded_year INTEGER,&#10;    website VARCHAR(255),&#10;    logo_url VARCHAR(500),&#10;    active BOOLEAN DEFAULT TRUE,&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Tabella degli aerei&#10;CREATE TABLE IF NOT EXISTS aircrafts (&#10;    id SERIAL PRIMARY KEY,&#10;    airline_id INTEGER REFERENCES airlines(id),&#10;    registration VARCHAR(10) UNIQUE NOT NULL,&#10;    aircraft_type VARCHAR(50) NOT NULL,&#10;    manufacturer VARCHAR(100) NOT NULL,&#10;    model VARCHAR(100) NOT NULL,&#10;    seat_capacity INTEGER NOT NULL,&#10;    business_class_seats INTEGER DEFAULT 0,&#10;    economy_class_seats INTEGER NOT NULL,&#10;    manufacturing_year INTEGER,&#10;    last_maintenance DATE,&#10;    status VARCHAR(20) DEFAULT 'active',&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE IF NOT EXISTS flights (&#10;    id SERIAL PRIMARY KEY,&#10;    flight_number VARCHAR(10) UNIQUE NOT NULL,&#10;    airline_id INTEGER REFERENCES airlines(id),&#10;    aircraft_id INTEGER REFERENCES aircrafts(id),&#10;    departure_airport_id INTEGER REFERENCES airports(id),&#10;    arrival_airport_id INTEGER REFERENCES airports(id),&#10;    departure_time TIMESTAMP NOT NULL,&#10;    arrival_time TIMESTAMP NOT NULL,&#10;    price DECIMAL(10, 2) NOT NULL,&#10;    total_seats INTEGER NOT NULL,&#10;    available_seats INTEGER NOT NULL,&#10;    status VARCHAR(20) DEFAULT 'scheduled',&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE IF NOT EXISTS bookings (&#10;    id SERIAL PRIMARY KEY,&#10;    user_id INTEGER REFERENCES users(id),&#10;    flight_id INTEGER REFERENCES flights(id),&#10;    booking_reference VARCHAR(20) UNIQUE NOT NULL,&#10;    passenger_count INTEGER NOT NULL,&#10;    total_price DECIMAL(10, 2) NOT NULL,&#10;    status VARCHAR(20) DEFAULT 'confirmed',&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Inserimento dati di test per aeroporti&#10;INSERT INTO airports (name, iata_code, city, country, latitude, longitude) VALUES&#10;('Leonardo da Vinci International Airport', 'FCO', 'Roma', 'Italy', 41.8003, 12.2389),&#10;('Milano Malpensa', 'MXP', 'Milano', 'Italy', 45.6306, 8.7281),&#10;('Heathrow Airport', 'LHR', 'London', 'United Kingdom', 51.4700, -0.4543),&#10;('Charles de Gaulle Airport', 'CDG', 'Paris', 'France', 49.0097, 2.5479),&#10;('Barcellona El Prat', 'BCN', 'Barcelona', 'Spain', 41.2971, 2.0785),&#10;('Amsterdam Schiphol', 'AMS', 'Amsterdam', 'Netherlands', 52.3086, 4.7639);&#10;&#10;-- Inserimento dati di test per compagnie aeree&#10;INSERT INTO airlines (name, iata_code, icao_code, country, founded_year, website, active) VALUES&#10;('Alitalia', 'AZ', 'AZA', 'Italy', 1946, 'https://www.alitalia.com', true),&#10;('British Airways', 'BA', 'BAW', 'United Kingdom', 1974, 'https://www.britishairways.com', true),&#10;('Air France', 'AF', 'AFR', 'France', 1933, 'https://www.airfrance.com', true),&#10;('Vueling', 'VY', 'VLG', 'Spain', 2004, 'https://www.vueling.com', true),&#10;('KLM', 'KL', 'KLM', 'Netherlands', 1919, 'https://www.klm.com', true),&#10;('Ryanair', 'FR', 'RYR', 'Ireland', 1984, 'https://www.ryanair.com', true);&#10;&#10;-- Inserimento dati di test per aerei&#10;INSERT INTO aircrafts (airline_id, registration, aircraft_type, manufacturer, model, seat_capacity, business_class_seats, economy_class_seats, manufacturing_year, status) VALUES&#10;(1, 'I-BIXM', 'Narrow-body', 'Airbus', 'A321', 200, 20, 180, 2019, 'active'),&#10;(1, 'I-BIXN', 'Narrow-body', 'Airbus', 'A320', 180, 12, 168, 2020, 'active'),&#10;(2, 'G-EUUU', 'Narrow-body', 'Airbus', 'A320', 180, 24, 156, 2018, 'active'),&#10;(2, 'G-EUYY', 'Wide-body', 'Boeing', '777-300ER', 350, 56, 294, 2017, 'active'),&#10;(3, 'F-HEPG', 'Narrow-body', 'Airbus', 'A320', 174, 12, 162, 2019, 'active'),&#10;(3, 'F-GRHZ', 'Wide-body', 'Boeing', '787-9', 276, 30, 246, 2020, 'active'),&#10;(4, 'EC-MBT', 'Narrow-body', 'Airbus', 'A320', 180, 0, 180, 2016, 'active'),&#10;(5, 'PH-BXA', 'Wide-body', 'Boeing', '737-800', 186, 20, 166, 2015, 'active'),&#10;(6, 'EI-DWF', 'Narrow-body', 'Boeing', '737-800', 189, 0, 189, 2014, 'active');&#10;&#10;-- Inserimento dati di test per voli&#10;INSERT INTO flights (flight_number, airline_id, aircraft_id, departure_airport_id, arrival_airport_id, departure_time, arrival_time, price, total_seats, available_seats, status) VALUES&#10;('AZ101', 1, 1, 1, 2, '2024-12-01 08:00:00', '2024-12-01 09:30:00', 89.99, 200, 156, 'scheduled'),&#10;('AZ102', 1, 2, 2, 1, '2024-12-01 10:30:00', '2024-12-01 12:00:00', 94.99, 180, 143, 'scheduled'),&#10;('BA205', 2, 3, 1, 3, '2024-12-01 14:15:00', '2024-12-01 16:45:00', 159.99, 180, 178, 'scheduled'),&#10;('AF301', 3, 5, 1, 4, '2024-12-01 11:20:00', '2024-12-01 13:30:00', 139.99, 174, 145, 'scheduled'),&#10;('VY402', 4, 7, 2, 5, '2024-12-01 07:45:00', '2024-12-01 09:15:00', 79.99, 180, 128, 'scheduled'),&#10;('KL503', 5, 8, 2, 6, '2024-12-01 16:00:00', '2024-12-01 17:20:00', 119.99, 186, 162, 'scheduled'),&#10;('AZ201', 1, 1, 1, 5, '2024-12-01 19:30:00', '2024-12-01 21:45:00', 169.99, 200, 141, 'scheduled'),&#10;('BA301', 2, 4, 3, 1, '2024-12-01 09:15:00', '2024-12-01 13:45:00', 149.99, 350, 289, 'scheduled');&#10;&#10;-- Creazione di un utente di test&#10;INSERT INTO users (email, password_hash, first_name, last_name, phone, role) VALUES&#10;('test@example.com', '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', 'Mario', 'Rossi', '+39 123 456 7890', 'user');&#10;&#10;-- Creazione degli admin delle compagnie aeree demo&#10;-- Password: alitalia123 -&gt; hash: $2a$10$rQ8K5O2bzA1Rl6y0vRf9/.bVEOZ1rQ8K5O2bzA1Rl6y0vRf9/.bVEO&#10;-- Password: lufthansa123 -&gt; hash: $2a$10$rQ8K5O2bzA1Rl6y0vRf9/.bVEOZ1rQ8K5O2bzA1Rl6y0vRf9/.bVEL&#10;-- Password: airfrance123 -&gt; hash: $2a$10$rQ8K5O2bzA1Rl6y0vRf9/.bVEOZ1rQ8K5O2bzA1Rl6y0vRf9/.bVEA&#10;-- Password: emirates123 -&gt; hash: $2a$10$rQ8K5O2bzA1Rl6y0vRf9/.bVEOZ1rQ8K5O2bzA1Rl6y0vRf9/.bVEE&#10;&#10;INSERT INTO users (email, password_hash, first_name, last_name, phone, role, airline_id, temporary_password) VALUES&#10;('admin@alitalia.com', '$2a$10$N9qo8uLOickgx2ZMRZoMye8CY8L5p7h5z.HYKPs1qXb1w0H.fGb6a', 'Admin', 'Alitalia', '+39 06 123456', 'airline_admin', 1, false),&#10;('admin@lufthansa.com', '$2a$10$N9qo8uLOickgx2ZMRZoMye8CY8L5p7h5z.HYKPs1qXb1w0H.fGb6a', 'Admin', 'Lufthansa', '+49 69 123456', 'airline_admin', 2, false),&#10;('admin@airfrance.com', '$2a$10$N9qo8uLOickgx2ZMRZoMye8CY8L5p7h5z.HYKPs1qXb1w0H.fGb6a', 'Admin', 'Air France', '+33 1 123456', 'airline_admin', 3, false),&#10;('admin@emirates.com', '$2a$10$N9qo8uLOickgx2ZMRZoMye8CY8L5p7h5z.HYKPs1qXb1w0H.fGb6a', 'Admin', 'Emirates', '+971 4 123456', 'airline_admin', 5, false);&#10;&#10;-- Creazione degli indici per migliorare le performance&#10;CREATE INDEX IF NOT EXISTS idx_flights_departure_time ON flights(departure_time);&#10;CREATE INDEX IF NOT EXISTS idx_flights_departure_airport ON flights(departure_airport_id);&#10;CREATE INDEX IF NOT EXISTS idx_flights_arrival_airport ON flights(arrival_airport_id);&#10;CREATE INDEX IF NOT EXISTS idx_flights_airline ON flights(airline_id);&#10;CREATE INDEX IF NOT EXISTS idx_flights_aircraft ON flights(aircraft_id);&#10;CREATE INDEX IF NOT EXISTS idx_bookings_user_id ON bookings(user_id);&#10;CREATE INDEX IF NOT EXISTS idx_bookings_flight_id ON bookings(flight_id);&#10;CREATE INDEX IF NOT EXISTS idx_aircrafts_airline ON aircrafts(airline_id);&#10;CREATE INDEX IF NOT EXISTS idx_aircrafts_status ON aircrafts(status);&#10;CREATE INDEX IF NOT EXISTS idx_airlines_active ON airlines(active);&#10;&#10;-- Output di conferma&#10;SELECT 'Database TAW Flights inizializzato con successo!' as status;&#10;" />
              <option name="updatedContent" value="-- Creazione database TAW Flights&#10;-- Script di inizializzazione PostgreSQL&#10;&#10;-- Prima creare airports e airlines (senza dipendenze)&#10;CREATE TABLE IF NOT EXISTS airports (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(255) NOT NULL,&#10;    iata_code VARCHAR(3) UNIQUE NOT NULL,&#10;    city VARCHAR(100) NOT NULL,&#10;    country VARCHAR(100) NOT NULL,&#10;    latitude DECIMAL(10, 8),&#10;    longitude DECIMAL(11, 8),&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Tabella delle compagnie aeree&#10;CREATE TABLE IF NOT EXISTS airlines (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(255) NOT NULL,&#10;    iata_code VARCHAR(2) UNIQUE NOT NULL,&#10;    icao_code VARCHAR(3) UNIQUE NOT NULL,&#10;    country VARCHAR(100) NOT NULL,&#10;    founded_year INTEGER,&#10;    website VARCHAR(255),&#10;    logo_url VARCHAR(500),&#10;    active BOOLEAN DEFAULT TRUE,&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- POI creare users (che referenzia airlines)&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    email VARCHAR(255) UNIQUE NOT NULL,&#10;    password_hash VARCHAR(255) NOT NULL,&#10;    first_name VARCHAR(100),&#10;    last_name VARCHAR(100),&#10;    phone VARCHAR(20),&#10;    role VARCHAR(20) NOT NULL DEFAULT 'user',&#10;    airline_id INTEGER REFERENCES airlines(id),&#10;    temporary_password BOOLEAN NOT NULL DEFAULT FALSE,&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Creazione delle tabelle&#10;CREATE TABLE IF NOT EXISTS aircrafts (&#10;    id SERIAL PRIMARY KEY,&#10;    airline_id INTEGER REFERENCES airlines(id),&#10;    registration VARCHAR(10) UNIQUE NOT NULL,&#10;    aircraft_type VARCHAR(50) NOT NULL,&#10;    manufacturer VARCHAR(100) NOT NULL,&#10;    model VARCHAR(100) NOT NULL,&#10;    seat_capacity INTEGER NOT NULL,&#10;    business_class_seats INTEGER DEFAULT 0,&#10;    economy_class_seats INTEGER NOT NULL,&#10;    manufacturing_year INTEGER,&#10;    last_maintenance DATE,&#10;    status VARCHAR(20) DEFAULT 'active',&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE IF NOT EXISTS flights (&#10;    id SERIAL PRIMARY KEY,&#10;    flight_number VARCHAR(10) UNIQUE NOT NULL,&#10;    airline_id INTEGER REFERENCES airlines(id),&#10;    aircraft_id INTEGER REFERENCES aircrafts(id),&#10;    departure_airport_id INTEGER REFERENCES airports(id),&#10;    arrival_airport_id INTEGER REFERENCES airports(id),&#10;    departure_time TIMESTAMP NOT NULL,&#10;    arrival_time TIMESTAMP NOT NULL,&#10;    price DECIMAL(10, 2) NOT NULL,&#10;    total_seats INTEGER NOT NULL,&#10;    available_seats INTEGER NOT NULL,&#10;    status VARCHAR(20) DEFAULT 'scheduled',&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;CREATE TABLE IF NOT EXISTS bookings (&#10;    id SERIAL PRIMARY KEY,&#10;    user_id INTEGER REFERENCES users(id),&#10;    flight_id INTEGER REFERENCES flights(id),&#10;    booking_reference VARCHAR(20) UNIQUE NOT NULL,&#10;    passenger_count INTEGER NOT NULL,&#10;    total_price DECIMAL(10, 2) NOT NULL,&#10;    status VARCHAR(20) DEFAULT 'confirmed',&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Inserimento dati di test per aeroporti&#10;INSERT INTO airports (name, iata_code, city, country, latitude, longitude) VALUES&#10;('Leonardo da Vinci International Airport', 'FCO', 'Roma', 'Italy', 41.8003, 12.2389),&#10;('Milano Malpensa', 'MXP', 'Milano', 'Italy', 45.6306, 8.7281),&#10;('Heathrow Airport', 'LHR', 'London', 'United Kingdom', 51.4700, -0.4543),&#10;('Charles de Gaulle Airport', 'CDG', 'Paris', 'France', 49.0097, 2.5479),&#10;('Barcellona El Prat', 'BCN', 'Barcelona', 'Spain', 41.2971, 2.0785),&#10;('Amsterdam Schiphol', 'AMS', 'Amsterdam', 'Netherlands', 52.3086, 4.7639);&#10;&#10;-- Inserimento dati di test per compagnie aeree&#10;INSERT INTO airlines (name, iata_code, icao_code, country, founded_year, website, active) VALUES&#10;('Alitalia', 'AZ', 'AZA', 'Italy', 1946, 'https://www.alitalia.com', true),&#10;('British Airways', 'BA', 'BAW', 'United Kingdom', 1974, 'https://www.britishairways.com', true),&#10;('Air France', 'AF', 'AFR', 'France', 1933, 'https://www.airfrance.com', true),&#10;('Vueling', 'VY', 'VLG', 'Spain', 2004, 'https://www.vueling.com', true),&#10;('KLM', 'KL', 'KLM', 'Netherlands', 1919, 'https://www.klm.com', true),&#10;('Ryanair', 'FR', 'RYR', 'Ireland', 1984, 'https://www.ryanair.com', true);&#10;&#10;-- Inserimento dati di test per aerei&#10;INSERT INTO aircrafts (airline_id, registration, aircraft_type, manufacturer, model, seat_capacity, business_class_seats, economy_class_seats, manufacturing_year, status) VALUES&#10;(1, 'I-BIXM', 'Narrow-body', 'Airbus', 'A321', 200, 20, 180, 2019, 'active'),&#10;(1, 'I-BIXN', 'Narrow-body', 'Airbus', 'A320', 180, 12, 168, 2020, 'active'),&#10;(2, 'G-EUUU', 'Narrow-body', 'Airbus', 'A320', 180, 24, 156, 2018, 'active'),&#10;(2, 'G-EUYY', 'Wide-body', 'Boeing', '777-300ER', 350, 56, 294, 2017, 'active'),&#10;(3, 'F-HEPG', 'Narrow-body', 'Airbus', 'A320', 174, 12, 162, 2019, 'active'),&#10;(3, 'F-GRHZ', 'Wide-body', 'Boeing', '787-9', 276, 30, 246, 2020, 'active'),&#10;(4, 'EC-MBT', 'Narrow-body', 'Airbus', 'A320', 180, 0, 180, 2016, 'active'),&#10;(5, 'PH-BXA', 'Wide-body', 'Boeing', '737-800', 186, 20, 166, 2015, 'active'),&#10;(6, 'EI-DWF', 'Narrow-body', 'Boeing', '737-800', 189, 0, 189, 2014, 'active');&#10;&#10;-- Inserimento dati di test per voli&#10;INSERT INTO flights (flight_number, airline_id, aircraft_id, departure_airport_id, arrival_airport_id, departure_time, arrival_time, price, total_seats, available_seats, status) VALUES&#10;('AZ101', 1, 1, 1, 2, '2024-12-01 08:00:00', '2024-12-01 09:30:00', 89.99, 200, 156, 'scheduled'),&#10;('AZ102', 1, 2, 2, 1, '2024-12-01 10:30:00', '2024-12-01 12:00:00', 94.99, 180, 143, 'scheduled'),&#10;('BA205', 2, 3, 1, 3, '2024-12-01 14:15:00', '2024-12-01 16:45:00', 159.99, 180, 178, 'scheduled'),&#10;('AF301', 3, 5, 1, 4, '2024-12-01 11:20:00', '2024-12-01 13:30:00', 139.99, 174, 145, 'scheduled'),&#10;('VY402', 4, 7, 2, 5, '2024-12-01 07:45:00', '2024-12-01 09:15:00', 79.99, 180, 128, 'scheduled'),&#10;('KL503', 5, 8, 2, 6, '2024-12-01 16:00:00', '2024-12-01 17:20:00', 119.99, 186, 162, 'scheduled'),&#10;('AZ201', 1, 1, 1, 5, '2024-12-01 19:30:00', '2024-12-01 21:45:00', 169.99, 200, 141, 'scheduled'),&#10;('BA301', 2, 4, 3, 1, '2024-12-01 09:15:00', '2024-12-01 13:45:00', 149.99, 350, 289, 'scheduled');&#10;&#10;-- Creazione di un utente di test&#10;INSERT INTO users (email, password_hash, first_name, last_name, phone, role) VALUES&#10;('test@example.com', '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', 'Mario', 'Rossi', '+39 123 456 7890', 'user');&#10;&#10;-- Creazione degli admin delle compagnie aeree demo&#10;-- Password: alitalia123 -&gt; hash: $2a$10$rQ8K5O2bzA1Rl6y0vRf9/.bVEOZ1rQ8K5O2bzA1Rl6y0vRf9/.bVEO&#10;-- Password: lufthansa123 -&gt; hash: $2a$10$rQ8K5O2bzA1Rl6y0vRf9/.bVEOZ1rQ8K5O2bzA1Rl6y0vRf9/.bVEL&#10;-- Password: airfrance123 -&gt; hash: $2a$10$rQ8K5O2bzA1Rl6y0vRf9/.bVEOZ1rQ8K5O2bzA1Rl6y0vRf9/.bVEA&#10;-- Password: emirates123 -&gt; hash: $2a$10$rQ8K5O2bzA1Rl6y0vRf9/.bVEOZ1rQ8K5O2bzA1Rl6y0vRf9/.bVEE&#10;&#10;INSERT INTO users (email, password_hash, first_name, last_name, phone, role, airline_id, temporary_password) VALUES&#10;('admin@alitalia.com', '$2a$10$N9qo8uLOickgx2ZMRZoMye8CY8L5p7h5z.HYKPs1qXb1w0H.fGb6a', 'Admin', 'Alitalia', '+39 06 123456', 'airline_admin', 1, false),&#10;('admin@lufthansa.com', '$2a$10$N9qo8uLOickgx2ZMRZoMye8CY8L5p7h5z.HYKPs1qXb1w0H.fGb6a', 'Admin', 'Lufthansa', '+49 69 123456', 'airline_admin', 2, false),&#10;('admin@airfrance.com', '$2a$10$N9qo8uLOickgx2ZMRZoMye8CY8L5p7h5z.HYKPs1qXb1w0H.fGb6a', 'Admin', 'Air France', '+33 1 123456', 'airline_admin', 3, false),&#10;('admin@emirates.com', '$2a$10$N9qo8uLOickgx2ZMRZoMye8CY8L5p7h5z.HYKPs1qXb1w0H.fGb6a', 'Admin', 'Emirates', '+971 4 123456', 'airline_admin', 5, false);&#10;&#10;-- Creazione degli indici per migliorare le performance&#10;CREATE INDEX IF NOT EXISTS idx_flights_departure_time ON flights(departure_time);&#10;CREATE INDEX IF NOT EXISTS idx_flights_departure_airport ON flights(departure_airport_id);&#10;CREATE INDEX IF NOT EXISTS idx_flights_arrival_airport ON flights(arrival_airport_id);&#10;CREATE INDEX IF NOT EXISTS idx_flights_airline ON flights(airline_id);&#10;CREATE INDEX IF NOT EXISTS idx_flights_aircraft ON flights(aircraft_id);&#10;CREATE INDEX IF NOT EXISTS idx_bookings_user_id ON bookings(user_id);&#10;CREATE INDEX IF NOT EXISTS idx_bookings_flight_id ON bookings(flight_id);&#10;CREATE INDEX IF NOT EXISTS idx_aircrafts_airline ON aircrafts(airline_id);&#10;CREATE INDEX IF NOT EXISTS idx_aircrafts_status ON aircrafts(status);&#10;CREATE INDEX IF NOT EXISTS idx_airlines_active ON airlines(active);&#10;&#10;-- Output di conferma&#10;SELECT 'Database TAW Flights inizializzato con successo!' as status;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/app.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/app.ts" />
              <option name="originalContent" value="import express from 'express';&#10;import { Pool } from 'pg';&#10;import cors from 'cors';&#10;import helmet from 'helmet';&#10;import morgan from 'morgan';&#10;import path from 'path';&#10;import dotenv from 'dotenv';&#10;import jwt from 'jsonwebtoken';&#10;import bcrypt from 'bcryptjs';&#10;import {readFile} from &quot;node:fs/promises&quot;;&#10;import { DatabaseService } from './models/database';&#10;&#10;// Import routers&#10;import adminRouter from './routes/admin';&#10;import flightsRouter from './routes/flights';&#10;import authRouter from './routes/auth';&#10;import usersRouter from './routes/users';&#10;import routesRouter from './routes/routes';&#10;import airportsRouter from './routes/airports';&#10;import airlinesRouter from './routes/airlines';&#10;import aircraftsRouter from './routes/aircrafts';&#10;import bookingsRouter from './routes/bookings';&#10;&#10;// Load environment variables from workspace root .env&#10;dotenv.config({ path: path.resolve(__dirname, '../../.env') });&#10;console.debug('[DEBUG] Loaded .env from', path.resolve(__dirname, '../../.env'));&#10;console.debug('[DEBUG] DATABASE_URL:', process.env.DATABASE_URL);&#10;console.debug('[DEBUG] Routes imported successfully');&#10;&#10;// Debug global errors&#10;if (process.env.NODE_ENV === 'development') {&#10;    process.on('unhandledRejection', (reason, promise) =&gt; console.error('[UNHANDLED REJECTION]', reason, promise));&#10;}&#10;process.on('uncaughtException', err =&gt; console.error('[UNCAUGHT EXCEPTION]', err));&#10;&#10;const app = express();&#10;&#10;// Constants&#10;const PORT = parseInt(process.env.PORT || '3000', 10);&#10;const JWT_SECRET = process.env.JWT_SECRET || 'default-secret-change-in-production';&#10;&#10;// Database connection&#10;const pool = new Pool({&#10;    connectionString: process.env.DATABASE_URL,&#10;});&#10;&#10;// Database service instance&#10;const dbService = new DatabaseService(pool);&#10;&#10;async function runInitSql() {&#10;    try {&#10;        const initSqlPath = path.resolve(__dirname, '../database-init/init.sql');&#10;        const sqlContent = await readFile(initSqlPath, 'utf-8');&#10;        &#10;        console.debug('[DEBUG] Running SQL initialization from:', initSqlPath);&#10;        await pool.query(sqlContent);&#10;        console.debug('[DEBUG] SQL initialization completed successfully');&#10;    } catch (error: any) {&#10;        if (error.code === '23505') {&#10;            console.warn('[WARN] init.sql: duplicate key violation, skipping initialization');&#10;        } else {&#10;            console.error('[ERROR] Failed to run SQL initialization:', error);&#10;            throw error;&#10;        }&#10;    }&#10;}&#10;&#10;// Funzione per creare l'admin automaticamente se non esiste&#10;async function createAdminIfNotExists() {&#10;    try {&#10;        const adminEmail = process.env.ADMIN_EMAIL;&#10;        const adminPassword = process.env.ADMIN_PASSWORD;&#10;&#10;        if (!adminEmail || !adminPassword) {&#10;            console.warn('[WARN] ADMIN_EMAIL or ADMIN_PASSWORD not found in environment variables');&#10;            return;&#10;        }&#10;&#10;        // Controlla se esiste già un admin&#10;        const existingAdmin = await pool.query(&#10;            'SELECT id FROM users WHERE role = $1 LIMIT 1',&#10;            ['admin']&#10;        );&#10;&#10;        if (existingAdmin.rows.length &gt; 0) {&#10;            console.debug('[DEBUG] Admin user already exists, skipping creation');&#10;            return;&#10;        }&#10;&#10;        // Hash della password&#10;        const saltRounds = 10;&#10;        const passwordHash = await bcrypt.hash(adminPassword, saltRounds);&#10;&#10;        // Crea l'admin&#10;        const result = await pool.query(&#10;            `INSERT INTO users (email, password_hash, first_name, last_name, role, temporary_password) &#10;             VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, email, role`,&#10;            [adminEmail, passwordHash, 'Admin', 'User', 'admin', false]&#10;        );&#10;&#10;        console.log('[INFO] Admin user created successfully:', {&#10;            id: result.rows[0].id,&#10;            email: result.rows[0].email,&#10;            role: result.rows[0].role&#10;        });&#10;&#10;    } catch (error) {&#10;        console.error('[ERROR] Failed to create admin user:', error);&#10;        throw error;&#10;    }&#10;}&#10;&#10;// Middleware&#10;app.use(express.json());&#10;app.use(cors({&#10;    origin: ['http://localhost:4200', 'http://127.0.0.1:4200'],&#10;    credentials: true,&#10;    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],&#10;    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']&#10;}));&#10;app.use(helmet());&#10;app.use(morgan('combined'));&#10;&#10;// Debug request middleware&#10;app.use((req, res, next) =&gt; {&#10;    console.debug(`[DEBUG] ${new Date().toISOString()} - ${req.method} ${req.originalUrl}`);&#10;    next();&#10;});&#10;&#10;// Authentication middleware&#10;function authenticateToken(req: express.Request, res: express.Response, next: express.NextFunction) {&#10;    const authHeader = req.headers['authorization'];&#10;    const token = authHeader &amp;&amp; authHeader.split(' ')[1];&#10;    if (!token) return res.sendStatus(401);&#10;&#10;    try {&#10;        const payload = jwt.verify(token, JWT_SECRET) as {&#10;            userId: number;&#10;            role: string;&#10;        };&#10;        (req as any).userId = payload.userId;&#10;        (req as any).userRole = payload.role;&#10;        console.debug('[DEBUG] Token verified for userId:', payload.userId, 'with role:', payload.role);&#10;        next();&#10;    } catch (err) {&#10;        return res.sendStatus(403);&#10;    }&#10;}&#10;&#10;function verifyRole(requiredRole: string) {&#10;    return (req: express.Request, res: express.Response, next: express.NextFunction) =&gt; {&#10;        const role = (req as any).userRole;&#10;        if (role !== requiredRole) {&#10;            return res.status(403).json({error: 'Accesso negato: ruolo non autorizzato'});&#10;        }&#10;        next();&#10;    };&#10;}&#10;&#10;// Health check endpoint&#10;app.get('/api/health', (_req: express.Request, res: express.Response) =&gt; {&#10;    res.json({&#10;        status: 'ok',&#10;        timestamp: new Date().toISOString(),&#10;        port: PORT,&#10;        database: 'PostgreSQL'&#10;    });&#10;});&#10;&#10;// Test database connection endpoint&#10;app.get('/api/db-test', async (_req: express.Request, res: express.Response) =&gt; {&#10;    try {&#10;        const client = await pool.connect();&#10;        const result = await client.query('SELECT NOW() as current_time, version() as db_version');&#10;        client.release();&#10;        res.json({&#10;            status: 'connected',&#10;            time: result.rows[0].current_time,&#10;            version: result.rows[0].db_version,&#10;            database: 'PostgreSQL'&#10;        });&#10;    } catch (error) {&#10;        res.status(500).json({&#10;            status: 'error',&#10;            message: 'Errore connessione database',&#10;            error: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// API test endpoint&#10;app.get('/api/test', (_req: express.Request, res: express.Response) =&gt; {&#10;    res.json({&#10;        message: 'API funzionante',&#10;        data: {&#10;            utenti: ['admin', 'compagnia1', 'passeggero1'],&#10;            voli: [&#10;                { id: 1, partenza: 'Roma', arrivo: 'Milano', costo: 120 },&#10;                { id: 2, partenza: 'Milano', arrivo: 'Parigi', costo: 180 }&#10;            ]&#10;        }&#10;    });&#10;});&#10;&#10;// Mount routers&#10;app.use('/api/admin', adminRouter);&#10;app.use('/api/flights', flightsRouter);&#10;app.use('/api/auth', authRouter);&#10;app.use('/api/users', usersRouter);&#10;app.use('/api/routes', routesRouter);&#10;app.use('/api/airports', airportsRouter);&#10;app.use('/api/airlines', airlinesRouter);&#10;app.use('/api/aircrafts', aircraftsRouter);&#10;app.use('/api/bookings', bookingsRouter);&#10;&#10;// Default route&#10;app.get('/', (req, res) =&gt; {&#10;    res.json({&#10;        message: 'Flight Management API',&#10;        version: '1.0.0',&#10;        endpoints: {&#10;            health: '/api/health',&#10;            dbTest: '/api/db-test',&#10;            flights: '/api/flights',&#10;            auth: '/api/auth',&#10;            users: '/api/users',&#10;            routes: '/api/routes',&#10;            airports: '/api/airports',&#10;            airlines: '/api/airlines',&#10;            aircrafts: '/api/aircrafts',&#10;            bookings: '/api/bookings',&#10;            admin: '/api/admin'&#10;        }&#10;    });&#10;});&#10;&#10;// Error handling middleware&#10;app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) =&gt; {&#10;    console.error('[ERROR]', err.stack);&#10;    res.status(500).json({&#10;        error: 'Errore interno del server',&#10;        message: process.env.NODE_ENV === 'development' ? err.message : 'Internal Server Error'&#10;    });&#10;});&#10;&#10;// 404 handler&#10;app.use((req: express.Request, res: express.Response) =&gt; {&#10;    res.status(404).json({&#10;        error: 'Endpoint non trovato',&#10;        path: req.originalUrl,&#10;        method: req.method&#10;    });&#10;});&#10;&#10;async function connectToDatabase() {&#10;    try {&#10;        const databaseUrl = process.env.DATABASE_URL;&#10;        if (!databaseUrl) {&#10;            throw new Error('DATABASE_URL non definita nelle variabili d\'ambiente');&#10;        }&#10;&#10;        // Test database connection&#10;        console.debug('[DEBUG] Connecting to database using', databaseUrl);&#10;        const client = await pool.connect();&#10;        await client.query('SELECT 1');&#10;        client.release();&#10;        &#10;        console.log('✅ Connesso a PostgreSQL (Neon)');&#10;    } catch (error) {&#10;        console.error('❌ Errore connessione database:', error);&#10;        process.exit(1);&#10;    }&#10;}&#10;&#10;async function ensureAdminExists() {&#10;    console.log('[DEBUG] ADMIN_EMAIL:', process.env.ADMIN_EMAIL);&#10;    console.log('[DEBUG] ADMIN_PASSWORD:', process.env.ADMIN_PASSWORD ? '***' : 'undefined');&#10;    &#10;    if (!process.env.ADMIN_EMAIL || !process.env.ADMIN_PASSWORD) {&#10;        console.log('[WARN] Admin credentials not configured, skipping admin creation');&#10;        return;&#10;    }&#10;    &#10;    const existing = await dbService.getUserByEmail(process.env.ADMIN_EMAIL!);&#10;    if (!existing) {&#10;        const hash = await bcrypt.hash(process.env.ADMIN_PASSWORD!, 10);&#10;        await dbService.createUser({&#10;            email: process.env.ADMIN_EMAIL!,&#10;            password_hash: hash,&#10;            first_name: 'Super',&#10;            last_name: 'Admin',&#10;            phone: '',&#10;            role: 'admin',&#10;            temporary_password: false,&#10;            created_at: new Date(),&#10;            updated_at: new Date()&#10;        });&#10;        console.log('✅ Admin user created:', process.env.ADMIN_EMAIL);&#10;    }&#10;}&#10;&#10;// Server startup&#10;async function startServer() {&#10;    try {&#10;        console.log('[INFO] Initializing database...');&#10;        await connectToDatabase();&#10;        await runInitSql();&#10;        await createAdminIfNotExists();&#10;        await ensureAdminExists();&#10;        &#10;        app.listen(PORT, '0.0.0.0', () =&gt; {&#10;            console.log(` Server in ascolto su http://0.0.0.0:${PORT}`);&#10;            console.log(` Health check: http://0.0.0.0:${PORT}/api/health`);&#10;            console.log(` API documentation: http://0.0.0.0:${PORT}/`);&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Failed to start server:', error);&#10;        process.exit(1);&#10;    }&#10;}&#10;&#10;startServer();&#10;&#10;export default app;&#10;" />
              <option name="updatedContent" value="import express from 'express';&#10;import { Pool } from 'pg';&#10;import cors from 'cors';&#10;import helmet from 'helmet';&#10;import morgan from 'morgan';&#10;import path from 'path';&#10;import dotenv from 'dotenv';&#10;import jwt from 'jsonwebtoken';&#10;import bcrypt from 'bcryptjs';&#10;import {readFile} from &quot;node:fs/promises&quot;;&#10;import { DatabaseService } from './models/database';&#10;&#10;// Import routers&#10;import adminRouter from './routes/admin';&#10;import flightsRouter from './routes/flights';&#10;import authRouter from './routes/auth';&#10;import usersRouter from './routes/users';&#10;import routesRouter from './routes/routes';&#10;import airportsRouter from './routes/airports';&#10;import airlinesRouter from './routes/airlines';&#10;import aircraftsRouter from './routes/aircrafts';&#10;import bookingsRouter from './routes/bookings';&#10;&#10;// Load environment variables from workspace root .env&#10;dotenv.config({ path: path.resolve(__dirname, '../../.env') });&#10;console.debug('[DEBUG] Loaded .env from', path.resolve(__dirname, '../../.env'));&#10;console.debug('[DEBUG] DATABASE_URL:', process.env.DATABASE_URL);&#10;console.debug('[DEBUG] Routes imported successfully');&#10;&#10;// Debug global errors&#10;if (process.env.NODE_ENV === 'development') {&#10;    process.on('unhandledRejection', (reason, promise) =&gt; console.error('[UNHANDLED REJECTION]', reason, promise));&#10;}&#10;process.on('uncaughtException', err =&gt; console.error('[UNCAUGHT EXCEPTION]', err));&#10;&#10;const app = express();&#10;&#10;// Constants&#10;const PORT = parseInt(process.env.PORT || '3000', 10);&#10;const JWT_SECRET = process.env.JWT_SECRET || 'default-secret-change-in-production';&#10;&#10;// Database connection&#10;const pool = new Pool({&#10;    connectionString: process.env.DATABASE_URL,&#10;});&#10;&#10;// Database service instance&#10;const dbService = new DatabaseService(pool);&#10;&#10;async function runInitSql() {&#10;    try {&#10;        const initSqlPath = path.resolve(__dirname, '../database-init/init.sql');&#10;        const sqlContent = await readFile(initSqlPath, 'utf-8');&#10;        &#10;        console.debug('[DEBUG] Running SQL initialization from:', initSqlPath);&#10;        await pool.query(sqlContent);&#10;        console.debug('[DEBUG] SQL initialization completed successfully');&#10;    } catch (error: any) {&#10;        if (error.code === '23505') {&#10;            console.warn('[WARN] init.sql: duplicate key violation, skipping initialization');&#10;        } else {&#10;            console.error('[ERROR] Failed to run SQL initialization:', error);&#10;            throw error;&#10;        }&#10;    }&#10;}&#10;&#10;// Funzione per creare l'admin automaticamente se non esiste&#10;async function createAdminIfNotExists() {&#10;    try {&#10;        console.log('[INFO] Skipping admin creation - using existing Neon database structure');&#10;        return; // Disabilita temporaneamente per Neon&#10;&#10;        /* COMENTATO PER NEON - Riabilitare quando la struttura è corretta&#10;        const adminEmail = process.env.ADMIN_EMAIL;&#10;        const adminPassword = process.env.ADMIN_PASSWORD;&#10;&#10;        if (!adminEmail || !adminPassword) {&#10;            console.warn('[WARN] ADMIN_EMAIL or ADMIN_PASSWORD not found in environment variables');&#10;            return;&#10;        }&#10;&#10;        // Controlla se esiste già un admin&#10;        const existingAdmin = await pool.query(&#10;            'SELECT id FROM users WHERE role = $1 LIMIT 1',&#10;            ['admin']&#10;        );&#10;&#10;        if (existingAdmin.rows.length &gt; 0) {&#10;            console.debug('[DEBUG] Admin user already exists, skipping creation');&#10;            return;&#10;        }&#10;&#10;        // Hash della password&#10;        const saltRounds = 10;&#10;        const passwordHash = await bcrypt.hash(adminPassword, saltRounds);&#10;&#10;        // Crea l'admin&#10;        const result = await pool.query(&#10;            `INSERT INTO users (email, password_hash, first_name, last_name, role, temporary_password) &#10;             VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, email, role`,&#10;            [adminEmail, passwordHash, 'Admin', 'User', 'admin', false]&#10;        );&#10;&#10;        console.log('[INFO] Admin user created successfully:', {&#10;            id: result.rows[0].id,&#10;            email: result.rows[0].email,&#10;            role: result.rows[0].role&#10;        });&#10;        */&#10;&#10;    } catch (error) {&#10;        console.error('[ERROR] Admin creation disabled for Neon database');&#10;    }&#10;}&#10;&#10;// Middleware&#10;app.use(express.json());&#10;app.use(cors({&#10;    origin: ['http://localhost:4200', 'http://127.0.0.1:4200'],&#10;    credentials: true,&#10;    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],&#10;    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']&#10;}));&#10;app.use(helmet());&#10;app.use(morgan('combined'));&#10;&#10;// Debug request middleware&#10;app.use((req, res, next) =&gt; {&#10;    console.debug(`[DEBUG] ${new Date().toISOString()} - ${req.method} ${req.originalUrl}`);&#10;    next();&#10;});&#10;&#10;// Authentication middleware&#10;function authenticateToken(req: express.Request, res: express.Response, next: express.NextFunction) {&#10;    const authHeader = req.headers['authorization'];&#10;    const token = authHeader &amp;&amp; authHeader.split(' ')[1];&#10;    if (!token) return res.sendStatus(401);&#10;&#10;    try {&#10;        const payload = jwt.verify(token, JWT_SECRET) as {&#10;            userId: number;&#10;            role: string;&#10;        };&#10;        (req as any).userId = payload.userId;&#10;        (req as any).userRole = payload.role;&#10;        console.debug('[DEBUG] Token verified for userId:', payload.userId, 'with role:', payload.role);&#10;        next();&#10;    } catch (err) {&#10;        return res.sendStatus(403);&#10;    }&#10;}&#10;&#10;function verifyRole(requiredRole: string) {&#10;    return (req: express.Request, res: express.Response, next: express.NextFunction) =&gt; {&#10;        const role = (req as any).userRole;&#10;        if (role !== requiredRole) {&#10;            return res.status(403).json({error: 'Accesso negato: ruolo non autorizzato'});&#10;        }&#10;        next();&#10;    };&#10;}&#10;&#10;// Health check endpoint&#10;app.get('/api/health', (_req: express.Request, res: express.Response) =&gt; {&#10;    res.json({&#10;        status: 'ok',&#10;        timestamp: new Date().toISOString(),&#10;        port: PORT,&#10;        database: 'PostgreSQL'&#10;    });&#10;});&#10;&#10;// Test database connection endpoint&#10;app.get('/api/db-test', async (_req: express.Request, res: express.Response) =&gt; {&#10;    try {&#10;        const client = await pool.connect();&#10;        const result = await client.query('SELECT NOW() as current_time, version() as db_version');&#10;        client.release();&#10;        res.json({&#10;            status: 'connected',&#10;            time: result.rows[0].current_time,&#10;            version: result.rows[0].db_version,&#10;            database: 'PostgreSQL'&#10;        });&#10;    } catch (error) {&#10;        res.status(500).json({&#10;            status: 'error',&#10;            message: 'Errore connessione database',&#10;            error: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// API test endpoint&#10;app.get('/api/test', (_req: express.Request, res: express.Response) =&gt; {&#10;    res.json({&#10;        message: 'API funzionante',&#10;        data: {&#10;            utenti: ['admin', 'compagnia1', 'passeggero1'],&#10;            voli: [&#10;                { id: 1, partenza: 'Roma', arrivo: 'Milano', costo: 120 },&#10;                { id: 2, partenza: 'Milano', arrivo: 'Parigi', costo: 180 }&#10;            ]&#10;        }&#10;    });&#10;});&#10;&#10;// Mount routers&#10;app.use('/api/admin', adminRouter);&#10;app.use('/api/flights', flightsRouter);&#10;app.use('/api/auth', authRouter);&#10;app.use('/api/users', usersRouter);&#10;app.use('/api/routes', routesRouter);&#10;app.use('/api/airports', airportsRouter);&#10;app.use('/api/airlines', airlinesRouter);&#10;app.use('/api/aircrafts', aircraftsRouter);&#10;app.use('/api/bookings', bookingsRouter);&#10;&#10;// Default route&#10;app.get('/', (req, res) =&gt; {&#10;    res.json({&#10;        message: 'Flight Management API',&#10;        version: '1.0.0',&#10;        endpoints: {&#10;            health: '/api/health',&#10;            dbTest: '/api/db-test',&#10;            flights: '/api/flights',&#10;            auth: '/api/auth',&#10;            users: '/api/users',&#10;            routes: '/api/routes',&#10;            airports: '/api/airports',&#10;            airlines: '/api/airlines',&#10;            aircrafts: '/api/aircrafts',&#10;            bookings: '/api/bookings',&#10;            admin: '/api/admin'&#10;        }&#10;    });&#10;});&#10;&#10;// Error handling middleware&#10;app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) =&gt; {&#10;    console.error('[ERROR]', err.stack);&#10;    res.status(500).json({&#10;        error: 'Errore interno del server',&#10;        message: process.env.NODE_ENV === 'development' ? err.message : 'Internal Server Error'&#10;    });&#10;});&#10;&#10;// 404 handler&#10;app.use((req: express.Request, res: express.Response) =&gt; {&#10;    res.status(404).json({&#10;        error: 'Endpoint non trovato',&#10;        path: req.originalUrl,&#10;        method: req.method&#10;    });&#10;});&#10;&#10;async function connectToDatabase() {&#10;    try {&#10;        const databaseUrl = process.env.DATABASE_URL;&#10;        if (!databaseUrl) {&#10;            throw new Error('DATABASE_URL non definita nelle variabili d\'ambiente');&#10;        }&#10;&#10;        // Test database connection&#10;        console.debug('[DEBUG] Connecting to database using', databaseUrl);&#10;        const client = await pool.connect();&#10;        await client.query('SELECT 1');&#10;        client.release();&#10;        &#10;        console.log('✅ Connesso a PostgreSQL (Neon)');&#10;    } catch (error) {&#10;        console.error('❌ Errore connessione database:', error);&#10;        process.exit(1);&#10;    }&#10;}&#10;&#10;async function ensureAdminExists() {&#10;    console.log('[DEBUG] ADMIN_EMAIL:', process.env.ADMIN_EMAIL);&#10;    console.log('[DEBUG] ADMIN_PASSWORD:', process.env.ADMIN_PASSWORD ? '***' : 'undefined');&#10;    &#10;    if (!process.env.ADMIN_EMAIL || !process.env.ADMIN_PASSWORD) {&#10;        console.log('[WARN] Admin credentials not configured, skipping admin creation');&#10;        return;&#10;    }&#10;    &#10;    const existing = await dbService.getUserByEmail(process.env.ADMIN_EMAIL!);&#10;    if (!existing) {&#10;        const hash = await bcrypt.hash(process.env.ADMIN_PASSWORD!, 10);&#10;        await dbService.createUser({&#10;            email: process.env.ADMIN_EMAIL!,&#10;            password_hash: hash,&#10;            first_name: 'Super',&#10;            last_name: 'Admin',&#10;            phone: '',&#10;            role: 'admin',&#10;            temporary_password: false,&#10;            created_at: new Date(),&#10;            updated_at: new Date()&#10;        });&#10;        console.log('✅ Admin user created:', process.env.ADMIN_EMAIL);&#10;    }&#10;}&#10;&#10;// Server startup&#10;async function startServer() {&#10;    try {&#10;        console.log('[INFO] Initializing database...');&#10;        await connectToDatabase();&#10;        await runInitSql();&#10;        await createAdminIfNotExists();&#10;        await ensureAdminExists();&#10;        &#10;        app.listen(PORT, '0.0.0.0', () =&gt; {&#10;            console.log(` Server in ascolto su http://0.0.0.0:${PORT}`);&#10;            console.log(` Health check: http://0.0.0.0:${PORT}/api/health`);&#10;            console.log(` API documentation: http://0.0.0.0:${PORT}/`);&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Failed to start server:', error);&#10;        process.exit(1);&#10;    }&#10;}&#10;&#10;startServer();&#10;&#10;// ENDPOINT TEMPORANEO per modifiche database - RIMUOVERE in produzione&#10;app.get('/api/debug/drop-column/:columnName', async (req: express.Request, res: express.Response) =&gt; {&#10;    try {&#10;        const { columnName } = req.params;&#10;        &#10;        // ATTENZIONE: Solo per sviluppo!&#10;        if (process.env.NODE_ENV !== 'development') {&#10;            return res.status(403).json({ error: 'Endpoint disponibile solo in sviluppo' });&#10;        }&#10;        &#10;        console.log(`[DEBUG] Dropping column ${columnName} from users table`);&#10;        &#10;        // Verifica prima se la colonna esiste&#10;        const checkColumn = await pool.query(`&#10;            SELECT column_name &#10;            FROM information_schema.columns &#10;            WHERE table_name = 'users' AND column_name = $1&#10;        `, [columnName]);&#10;        &#10;        if (checkColumn.rows.length === 0) {&#10;            return res.json({ message: `Column ${columnName} does not exist` });&#10;        }&#10;        &#10;        // Elimina la colonna&#10;        await pool.query(`ALTER TABLE users DROP COLUMN ${columnName}`);&#10;        &#10;        res.json({ &#10;            message: `Column ${columnName} dropped successfully`,&#10;            timestamp: new Date().toISOString()&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Drop column failed:', error);&#10;        res.status(500).json({ &#10;            error: 'Errore nell\'eliminazione della colonna',&#10;            details: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;export default app;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/db/pool.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/db/pool.ts" />
              <option name="updatedContent" value="import { Pool } from 'pg';&#10;&#10;const pool = new Pool({&#10;  connectionString: process.env.DATABASE_URL,&#10;  ssl: { rejectUnauthorized: false }&#10;});&#10;&#10;export default pool;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/middleware/auth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/middleware/auth.ts" />
              <option name="originalContent" value="import { Request, Response, NextFunction } from 'express';&#10;import jwt, { JwtPayload } from 'jsonwebtoken';&#10;&#10;export interface AuthRequest extends Request {&#10;  userId?: number;&#10;  userRole?: string;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { Request, Response, NextFunction } from 'express';&#13;&#10;import jwt, { JwtPayload } from 'jsonwebtoken';&#13;&#10;&#13;&#10;export interface AuthRequest extends Request {&#13;&#10;  userId?: number;&#13;&#10;  userRole?: string;&#13;&#10;  airlineId?: number; // Aggiunto per supportare le compagnie aeree&#13;&#10;  airlineName?: string; // Aggiunto per supportare le compagnie aeree&#13;&#10;}&#13;&#10;&#13;&#10;// Interfaccia estesa per JWT payload delle compagnie aeree&#13;&#10;interface ExtendedJWTPayload extends JwtPayload {&#13;&#10;  userId: number;&#13;&#10;  role: string;&#13;&#10;  airlineId?: number;&#13;&#10;  airlineName?: string;&#13;&#10;}&#13;&#10;&#13;&#10;const JWT_SECRET = process.env.JWT_SECRET || 'secret';&#13;&#10;&#13;&#10;export function authenticateToken(req: AuthRequest, res: Response, next: NextFunction) {&#13;&#10;    const authHeader = req.headers['authorization'];&#13;&#10;    const token = authHeader &amp;&amp; authHeader.split(' ')[1];&#13;&#10;    if (!token) {&#13;&#10;        return res.sendStatus(401);&#13;&#10;    }&#13;&#10;    try {&#13;&#10;        const payload = jwt.verify(token, JWT_SECRET) as ExtendedJWTPayload;&#13;&#10;        req.userId = payload.userId;&#13;&#10;        req.userRole = payload.role;&#13;&#10;        req.airlineId = payload.airlineId; // Aggiunto supporto airline&#13;&#10;        req.airlineName = payload.airlineName; // Aggiunto supporto airline&#13;&#10;        console.debug('[DEBUG] Token verified for userId:', payload.userId, 'with role:', payload.role);&#13;&#10;        if (payload.airlineId) {&#13;&#10;            console.debug('[DEBUG] Airline context:', payload.airlineId, payload.airlineName);&#13;&#10;        }&#13;&#10;        next();&#13;&#10;    } catch (err) {&#13;&#10;        return res.sendStatus(403);&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;export function verifyRole(requiredRole: string) {&#13;&#10;    return (req: AuthRequest, res: Response, next: NextFunction) =&gt; {&#13;&#10;        if (req.userRole !== requiredRole) {&#13;&#10;            return res.status(403).json({ error: 'Accesso negato: ruolo non autorizzato' });&#13;&#10;        }&#13;&#10;        next();&#13;&#10;    };&#13;&#10;}&#13;&#10;&#13;&#10;// Middleware per verificare che l'utente sia admin di una compagnia aerea&#13;&#10;export function verifyAirlineAdmin(req: AuthRequest, res: Response, next: NextFunction) {&#13;&#10;    const userRole = req.userRole;&#13;&#10;    const airlineId = req.airlineId;&#13;&#10;    &#13;&#10;    if (userRole !== 'airline_admin') {&#13;&#10;        return res.status(403).json({ &#13;&#10;            error: 'Accesso riservato agli amministratori delle compagnie aeree' &#13;&#10;        });&#13;&#10;    }&#13;&#10;    &#13;&#10;    if (!airlineId) {&#13;&#10;        return res.status(403).json({ &#13;&#10;            error: 'ID compagnia aerea mancante nel token' &#13;&#10;        });&#13;&#10;    }&#13;&#10;    &#13;&#10;    console.debug('[DEBUG] Airline admin verified:', req.airlineName, '(ID:', airlineId, ')');&#13;&#10;    next();&#13;&#10;}&#13;&#10;&#13;&#10;// Middleware per verificare accesso ai dati di una specifica compagnia&#13;&#10;export function verifyAirlineAccess(req: AuthRequest, res: Response, next: NextFunction) {&#13;&#10;    const userRole = req.userRole;&#13;&#10;    const userAirlineId = req.airlineId;&#13;&#10;    &#13;&#10;    // Estrae l'ID della compagnia dalla richiesta (parametro URL o body)&#13;&#10;    const requestedAirlineId = parseInt(req.params.airlineId) || &#13;&#10;                              parseInt(req.body.airline_id) || &#13;&#10;                              parseInt(req.query.airline_id as string);&#13;&#10;    &#13;&#10;    if (userRole === 'admin') {&#13;&#10;        // Super admin può accedere a tutto&#13;&#10;        console.debug('[DEBUG] Super admin access granted');&#13;&#10;        next();&#13;&#10;    } else if (userRole === 'airline_admin' &amp;&amp; userAirlineId === requestedAirlineId) {&#13;&#10;        // Admin compagnia può accedere solo ai suoi dati&#13;&#10;        console.debug('[DEBUG] Airline admin access granted for own airline:', userAirlineId);&#13;&#10;        next();&#13;&#10;    } else {&#13;&#10;        console.warn('[WARN] Access denied - User airline:', userAirlineId, 'Requested:', requestedAirlineId);&#13;&#10;        res.status(403).json({ &#13;&#10;            error: 'Accesso negato: non puoi accedere ai dati di questa compagnia aerea' &#13;&#10;        });&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;// Middleware per verificare che l'utente sia admin generale O admin di compagnia&#13;&#10;export function verifyAdminOrAirlineAdmin(req: AuthRequest, res: Response, next: NextFunction) {&#13;&#10;    const userRole = req.userRole;&#13;&#10;    &#13;&#10;    if (userRole === 'admin' || userRole === 'airline_admin') {&#13;&#10;        console.debug('[DEBUG] Admin or airline admin access granted');&#13;&#10;        next();&#13;&#10;    } else {&#13;&#10;        res.status(403).json({ &#13;&#10;            error: 'Accesso riservato agli amministratori' &#13;&#10;        });&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;// Middleware per operazioni che richiedono solo admin generale&#13;&#10;export function verifySystemAdmin(req: AuthRequest, res: Response, next: NextFunction) {&#13;&#10;    const userRole = req.userRole;&#13;&#10;    &#13;&#10;    if (userRole !== 'admin') {&#13;&#10;        return res.status(403).json({ &#13;&#10;            error: 'Accesso riservato all\'amministratore di sistema' &#13;&#10;        });&#13;&#10;    }&#13;&#10;    &#13;&#10;    console.debug('[DEBUG] System admin access granted');&#13;&#10;    next();&#13;&#10;}&#13;&#10;&#13;&#10;// Helper function per verificare se un utente può gestire una risorsa di una compagnia&#13;&#10;export function canAccessAirlineResource(userRole: string, userAirlineId?: number, resourceAirlineId?: number): boolean {&#13;&#10;    if (userRole === 'admin') {&#13;&#10;        return true; // Super admin può tutto&#13;&#10;    }&#13;&#10;    &#13;&#10;    if (userRole === 'airline_admin' &amp;&amp; userAirlineId === resourceAirlineId) {&#13;&#10;        return true; // Admin può gestire solo la sua compagnia&#13;&#10;    }&#13;&#10;    &#13;&#10;    return false;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/models/database.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/models/database.ts" />
              <option name="originalContent" value="import { Pool, QueryResult } from 'pg';&#10;&#10;export interface User {&#10;    id: number;&#10;    email: string;&#10;    password_hash: string;&#10;    first_name: string;&#10;    last_name: string;&#10;    phone?: string;&#10;    role: 'user' | 'admin' | 'airlines';&#10;    temporary_password: boolean;&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Airline {&#10;    id: number;&#10;    name: string;&#10;    iata_code: string;&#10;    icao_code: string;&#10;    country: string;&#10;    founded_year?: number;&#10;    website?: string;&#10;    logo_url?: string;&#10;    active: boolean;&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Aircraft {&#10;    id: number;&#10;    airline_id: number;&#10;    registration: string;&#10;    aircraft_type: string;&#10;    manufacturer: string;&#10;    model: string;&#10;    seat_capacity: number;&#10;    business_class_seats: number;&#10;    economy_class_seats: number;&#10;    manufacturing_year?: number;&#10;    last_maintenance?: Date;&#10;    status: 'active' | 'maintenance' | 'retired';&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Flight {&#10;    id: number;&#10;    flight_number: string;&#10;    airline_id?: number;&#10;    aircraft_id?: number;&#10;    airline?: string;&#10;    aircraft?: string;&#10;    departure_airport: string;&#10;    departure_city?: string;&#10;    arrival_airport: string;&#10;    arrival_city?: string;&#10;    departure_time: Date;&#10;    arrival_time: Date;&#10;    price: number;&#10;    available_seats: number;&#10;    total_seats: number;&#10;    status: 'scheduled' | 'delayed' | 'cancelled' | 'completed';&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Booking {&#10;    id: number;&#10;    user_id: number;&#10;    flight_id: number;&#10;    booking_reference: string;&#10;    passenger_count: number;&#10;    total_price: number;&#10;    status: 'confirmed' | 'cancelled' | 'completed';&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Passenger {&#10;    id: number;&#10;    booking_id: number;&#10;    first_name: string;&#10;    last_name: string;&#10;    date_of_birth?: Date;&#10;    passport_number?: string;&#10;    nationality?: string;&#10;    seat_number?: string;&#10;    created_at: Date;&#10;}&#10;&#10;export class DatabaseService {&#10;    private pool: Pool;&#10;&#10;    constructor(pool: Pool) {&#10;        this.pool = pool;&#10;    }&#10;&#10;    // Utenti&#10;    async createUser(user: {&#10;        email: any;&#10;        password_hash: string;&#10;        first_name: any;&#10;        last_name: any;&#10;        phone: any;&#10;        role: any;&#10;        temporary_password: boolean;&#10;        created_at: Date;&#10;        updated_at: Date&#10;    }): Promise&lt;User&gt; {&#10;        const query = `&#10;            INSERT INTO users (email, password_hash, first_name, last_name, phone, role, temporary_password, created_at, updated_at)&#10;            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)&#10;            RETURNING *&#10;        `;&#10;        const values = [user.email, user.password_hash, user.first_name, user.last_name, user.phone, user.role, user.temporary_password, user.created_at, user.updated_at ];&#10;        const result = await this.pool.query(query, values);&#10;        return result.rows[0];&#10;    }&#10;&#10;    async getUserByEmail(email: string): Promise&lt;User | null&gt; {&#10;        const query = 'SELECT * FROM users WHERE email = $1';&#10;        const result = await this.pool.query(query, [email]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    async getUserById(id: number): Promise&lt;User | null&gt; {&#10;        const query = 'SELECT * FROM users WHERE id = $1';&#10;        const result = await this.pool.query(query, [id]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;            SELECT a.*, al.name as airline_name&#10;            FROM aircrafts a&#10;            LEFT JOIN airlines al ON a.airline_id = al.id&#10;            ORDER BY a.registration ASC&#10;        `;&#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    async getAircraftById(id: number): Promise&lt;Aircraft | null&gt; {&#10;        const query = `&#10;            SELECT a.*, al.name as airline_name&#10;            FROM aircrafts a&#10;            LEFT JOIN airlines al ON a.airline_id = al.id&#10;            WHERE a.id = $1&#10;        `;&#10;        const result = await this.pool.query(query, [id]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    async getAircraftsByAirline(airlineId: number): Promise&lt;Aircraft[]&gt; {&#10;        const query = `&#10;            SELECT a.*, al.name as airline_name&#10;            FROM aircrafts a&#10;            LEFT JOIN airlines al ON a.airline_id = al.id&#10;            WHERE a.airline_id = $1 AND a.status = 'active'&#10;            ORDER BY a.registration ASC&#10;        `;&#10;        const result = await this.pool.query(query, [airlineId]);&#10;        return result.rows;&#10;    }&#10;&#10;    async createAircraft(aircraft: Omit&lt;Aircraft, 'id' | 'created_at' | 'updated_at'&gt;): Promise&lt;Aircraft&gt; {&#10;        const query = `&#10;            INSERT INTO aircrafts (airline_id, registration, aircraft_type, manufacturer, model, &#10;                                 seat_capacity, business_class_seats, economy_class_seats, &#10;                                 manufacturing_year, last_maintenance, status)&#10;            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)&#10;            RETURNING *&#10;        `;&#10;        const values = [&#10;            aircraft.airline_id,&#10;            aircraft.registration,&#10;            aircraft.aircraft_type,&#10;            aircraft.manufacturer,&#10;            aircraft.model,&#10;            aircraft.seat_capacity,&#10;            aircraft.business_class_seats,&#10;            aircraft.economy_class_seats,&#10;            aircraft.manufacturing_year,&#10;            aircraft.last_maintenance,&#10;            aircraft.status&#10;        ];&#10;        const result = await this.pool.query(query, values);&#10;        return result.rows[0];&#10;    }&#10;&#10;    // Voli&#10;    async getAllFlights(): Promise&lt;Flight[]&gt; {&#10;        try {&#10;            // Prima verifichiamo la struttura della tabella&#10;            const checkQuery = `&#10;                SELECT column_name, data_type &#10;                FROM information_schema.columns &#10;                WHERE table_name = 'flights'&#10;                ORDER BY ordinal_position&#10;            `;&#10;            const checkResult = await this.pool.query(checkQuery);&#10;            console.log('Columns in flights table:', checkResult.rows);&#10;&#10;            // Facciamo una query semplice prima&#10;            const simpleQuery = `SELECT * FROM flights LIMIT 1`;&#10;            const simpleResult = await this.pool.query(simpleQuery);&#10;            console.log('Sample flight data:', simpleResult.rows[0]);&#10;&#10;            const query = `&#10;                SELECT &#10;                    f.*,&#10;                    da.name as departure_airport_name,&#10;                    da.city as departure_city,&#10;                    aa.name as arrival_airport_name,&#10;                    aa.city as arrival_city,&#10;                    al.name as airline_name,&#10;                    al.iata_code as airline_code,&#10;                    ac.registration as aircraft_registration,&#10;                    ac.model as aircraft_model&#10;                FROM flights f&#10;                LEFT JOIN airports da ON f.departure_airport_id = da.id&#10;                LEFT JOIN airports aa ON f.arrival_airport_id = aa.id&#10;                LEFT JOIN airlines al ON f.airline_id = al.id&#10;                LEFT JOIN aircrafts ac ON f.aircraft_id = ac.id&#10;                ORDER BY f.departure_time ASC&#10;            `;&#10;            const result = await this.pool.query(query);&#10;            &#10;            // Mappiamo i risultati al formato atteso&#10;            return result.rows.map(row =&gt; ({&#10;                id: row.id,&#10;                flight_number: row.flight_number,&#10;                airline_id: row.airline_id,&#10;                aircraft_id: row.aircraft_id,&#10;                airline: row.airline_name || row.airline_code || 'N/A',&#10;                aircraft: row.aircraft_registration ? `${row.aircraft_model} (${row.aircraft_registration})` : 'N/A',&#10;                departure_airport: row.departure_airport_name || row.departure_airport || 'N/A',&#10;                departure_city: row.departure_city || 'N/A',&#10;                arrival_airport: row.arrival_airport_name || row.arrival_airport || 'N/A',&#10;                arrival_city: row.arrival_city || 'N/A',&#10;                departure_time: row.departure_time,&#10;                arrival_time: row.arrival_time,&#10;                price: row.price,&#10;                available_seats: row.available_seats || 0,&#10;                total_seats: row.total_seats || 0,&#10;                status: row.status,&#10;                created_at: row.created_at,&#10;                updated_at: row.updated_at&#10;            }));&#10;        } catch (error) {&#10;            console.error('Error in getAllFlights:', error);&#10;            throw error;&#10;        }&#10;    }&#10;&#10;    async getFlightById(id: number): Promise&lt;Flight | null&gt; {&#10;        const query = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;            WHERE f.id = $1&#10;        `;&#10;        const result = await this.pool.query(query, [id]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    async searchFlights(departureAirport: string, arrivalAirport: string, departureDate: string): Promise&lt;Flight[]&gt; {&#10;        const query = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;            WHERE da.name = $1 &#10;            AND aa.name = $2 &#10;            AND DATE(f.departure_time) = $3&#10;            AND f.status = 'scheduled'&#10;            AND f.available_seats &gt; 0&#10;            ORDER BY f.departure_time ASC&#10;        `;&#10;        const result = await this.pool.query(query, [departureAirport, arrivalAirport, departureDate]);&#10;        const appo='s';&#10;        return result.rows; &#10;    }&#10;&#10;    // Prenotazioni&#10;    async createBooking(booking: Omit&lt;Booking, 'id' | 'created_at' | 'updated_at'&gt;): Promise&lt;Booking&gt; {&#10;        const query = `&#10;            INSERT INTO bookings (user_id, flight_id, booking_reference, passenger_count, total_price, status)&#10;            VALUES ($1, $2, $3, $4, $5, $6)&#10;            RETURNING *&#10;        `;&#10;        const values = [&#10;            booking.user_id,&#10;            booking.flight_id,&#10;            booking.booking_reference,&#10;            booking.passenger_count,&#10;            booking.total_price,&#10;            booking.status&#10;        ];&#10;        const result = await this.pool.query(query, values);&#10;        return result.rows[0];&#10;    }&#10;&#10;    async getBookingsByUserId(userId: number): Promise&lt;Booking[]&gt; {&#10;        const query = `&#10;            SELECT b.*, f.flight_number, f.airline, f.departure_airport, f.arrival_airport, &#10;                   f.departure_time, f.arrival_time&#10;            FROM bookings b&#10;            JOIN flights f ON b.flight_id = f.id&#10;            WHERE b.user_id = $1&#10;            ORDER BY b.created_at DESC&#10;        `;&#10;        const result = await this.pool.query(query, [userId]);&#10;        return result.rows;&#10;    }&#10;&#10;    async getBookingByReference(reference: string): Promise&lt;Booking | null&gt; {&#10;        const query = 'SELECT * FROM bookings WHERE booking_reference = $1';&#10;        const result = await this.pool.query(query, [reference]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    // Utility per aggiornare i posti disponibili&#10;    async updateFlightSeats(flightId: number, seatChange: number): Promise&lt;void&gt; {&#10;        const query = `&#10;            UPDATE flights &#10;            SET available_seats = available_seats + $1,&#10;                updated_at = CURRENT_TIMESTAMP&#10;            WHERE id = $2&#10;        `;&#10;        await this.pool.query(query, [seatChange, flightId]);&#10;    }&#10;&#10;    // Metodi per supportare i filtri del frontend&#10;    async getActiveFlights(): Promise&lt;Flight[]&gt; {&#10;        const query = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;            WHERE f.status IN ('scheduled', 'delayed') &#10;            ORDER BY f.departure_time ASC&#10;        `;&#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    async getOnTimeFlights(): Promise&lt;Flight[]&gt; {&#10;        const query = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;            WHERE f.status = 'scheduled'&#10;            ORDER BY f.departure_time ASC&#10;        `;&#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    async filterFlights(filterType: 'all' | 'departures' | 'arrivals'): Promise&lt;Flight[]&gt; {&#10;        let query: string;&#10;        &#10;        const baseQuery = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;        `;&#10;        &#10;        switch (filterType) {&#10;            case 'departures':&#10;                query = baseQuery + `&#10;                    WHERE f.departure_time::date = CURRENT_DATE&#10;                    ORDER BY f.departure_time ASC&#10;                `;&#10;                break;&#10;            case 'arrivals':&#10;                query = baseQuery + `&#10;                    WHERE f.arrival_time::date = CURRENT_DATE&#10;                    ORDER BY f.arrival_time ASC&#10;                `;&#10;                break;&#10;            default: // 'all'&#10;                query = baseQuery + ' ORDER BY f.departure_time ASC';&#10;        }&#10;        &#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    // Query personalizzate&#10;    async executeQuery(query: string, values?: any[]): Promise&lt;QueryResult&gt; {&#10;        return await this.pool.query(query, values);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import { Pool, QueryResult } from 'pg';&#10;&#10;export interface User {&#10;    id: number;&#10;    email: string;&#10;    password_hash: string;&#10;    first_name: string;&#10;    last_name: string;&#10;    phone?: string;&#10;    role: 'user' | 'admin' | 'airline_admin';&#10;    airline_id?: number; // Campo aggiunto per collegamento alle compagnie aeree&#10;    temporary_password: boolean;&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Airline {&#10;    id: number;&#10;    name: string;&#10;    iata_code: string;&#10;    icao_code: string;&#10;    country: string;&#10;    founded_year?: number;&#10;    website?: string;&#10;    logo_url?: string;&#10;    active: boolean;&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Aircraft {&#10;    id: number;&#10;    airline_id: number;&#10;    registration: string;&#10;    aircraft_type: string;&#10;    manufacturer: string;&#10;    model: string;&#10;    seat_capacity: number;&#10;    business_class_seats: number;&#10;    economy_class_seats: number;&#10;    manufacturing_year?: number;&#10;    last_maintenance?: Date;&#10;    status: 'active' | 'maintenance' | 'retired';&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Flight {&#10;    id: number;&#10;    flight_number: string;&#10;    airline_id?: number;&#10;    aircraft_id?: number;&#10;    airline?: string;&#10;    aircraft?: string;&#10;    departure_airport: string;&#10;    departure_city?: string;&#10;    arrival_airport: string;&#10;    arrival_city?: string;&#10;    departure_time: Date;&#10;    arrival_time: Date;&#10;    price: number;&#10;    available_seats: number;&#10;    total_seats: number;&#10;    status: 'scheduled' | 'delayed' | 'cancelled' | 'completed';&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Booking {&#10;    id: number;&#10;    user_id: number;&#10;    flight_id: number;&#10;    booking_reference: string;&#10;    passenger_count: number;&#10;    total_price: number;&#10;    status: 'confirmed' | 'cancelled' | 'completed';&#10;    created_at: Date;&#10;    updated_at: Date;&#10;}&#10;&#10;export interface Passenger {&#10;    id: number;&#10;    booking_id: number;&#10;    first_name: string;&#10;    last_name: string;&#10;    date_of_birth?: Date;&#10;    passport_number?: string;&#10;    nationality?: string;&#10;    seat_number?: string;&#10;    created_at: Date;&#10;}&#10;&#10;export class DatabaseService {&#10;    private pool: Pool;&#10;&#10;    constructor(pool: Pool) {&#10;        this.pool = pool;&#10;    }&#10;&#10;    // Utenti&#10;    async createUser(user: {&#10;        email: any;&#10;        password_hash: string;&#10;        first_name: any;&#10;        last_name: any;&#10;        phone: any;&#10;        role: any;&#10;        airline_id?: number; // Campo aggiunto&#10;        temporary_password: boolean;&#10;        created_at: Date;&#10;        updated_at: Date&#10;    }): Promise&lt;User&gt; {&#10;        const query = `&#10;            INSERT INTO users (email, password_hash, first_name, last_name, phone, role, airline_id, temporary_password, created_at, updated_at)&#10;            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)&#10;            RETURNING *&#10;        `;&#10;        const values = [&#10;            user.email, &#10;            user.password_hash, &#10;            user.first_name, &#10;            user.last_name, &#10;            user.phone, &#10;            user.role, &#10;            user.airline_id || null, // Supporta null se non è un admin di compagnia&#10;            user.temporary_password, &#10;            user.created_at, &#10;            user.updated_at&#10;        ];&#10;        const result = await this.pool.query(query, values);&#10;        return result.rows[0];&#10;    }&#10;&#10;    async getUserByEmail(email: string): Promise&lt;User | null&gt; {&#10;        const query = 'SELECT * FROM users WHERE email = $1';&#10;        const result = await this.pool.query(query, [email]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    async getUserById(id: number): Promise&lt;User | null&gt; {&#10;        const query = 'SELECT * FROM users WHERE id = $1';&#10;        const result = await this.pool.query(query, [id]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    // Add method to retrieve all users&#10;    async getAllUsers(): Promise&lt;User[]&gt; {&#10;        const query = 'SELECT * FROM users ORDER BY id ASC';&#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    // Add method to delete a user by ID&#10;    async deleteUserById(id: number): Promise&lt;void&gt; {&#10;        await this.pool.query('DELETE FROM users WHERE id = $1', [id]);&#10;    }&#10;&#10;    // Compagnie aeree&#10;    async getAllAirlines(): Promise&lt;Airline[]&gt; {&#10;        const query = 'SELECT * FROM airlines WHERE active = true ORDER BY name ASC';&#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    async getAirlineById(id: number): Promise&lt;Airline | null&gt; {&#10;        const query = 'SELECT * FROM airlines WHERE id = $1';&#10;        const result = await this.pool.query(query, [id]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    async createAirline(airline: Omit&lt;Airline, 'id' | 'created_at' | 'updated_at'&gt;): Promise&lt;Airline&gt; {&#10;        const query = `&#10;            INSERT INTO airlines (name, iata_code, icao_code, country, founded_year, website, logo_url, active)&#10;            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)&#10;            RETURNING *&#10;        `;&#10;        const values = [&#10;            airline.name,&#10;            airline.iata_code,&#10;            airline.icao_code,&#10;            airline.country,&#10;            airline.founded_year,&#10;            airline.website,&#10;            airline.logo_url,&#10;            airline.active&#10;        ];&#10;        const result = await this.pool.query(query, values);&#10;        return result.rows[0];&#10;    }&#10;&#10;    // Aerei&#10;    async getAllAircrafts(): Promise&lt;Aircraft[]&gt; {&#10;        const query = `&#10;            SELECT a.*, al.name as airline_name&#10;            FROM aircrafts a&#10;            LEFT JOIN airlines al ON a.airline_id = al.id&#10;            ORDER BY a.registration ASC&#10;        `;&#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    async getAircraftById(id: number): Promise&lt;Aircraft | null&gt; {&#10;        const query = `&#10;            SELECT a.*, al.name as airline_name&#10;            FROM aircrafts a&#10;            LEFT JOIN airlines al ON a.airline_id = al.id&#10;            WHERE a.id = $1&#10;        `;&#10;        const result = await this.pool.query(query, [id]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    async getAircraftsByAirline(airlineId: number): Promise&lt;Aircraft[]&gt; {&#10;        const query = `&#10;            SELECT a.*, al.name as airline_name&#10;            FROM aircrafts a&#10;            LEFT JOIN airlines al ON a.airline_id = al.id&#10;            WHERE a.airline_id = $1 AND a.status = 'active'&#10;            ORDER BY a.registration ASC&#10;        `;&#10;        const result = await this.pool.query(query, [airlineId]);&#10;        return result.rows;&#10;    }&#10;&#10;    async createAircraft(aircraft: Omit&lt;Aircraft, 'id' | 'created_at' | 'updated_at'&gt;): Promise&lt;Aircraft&gt; {&#10;        const query = `&#10;            INSERT INTO aircrafts (airline_id, registration, aircraft_type, manufacturer, model, &#10;                                 seat_capacity, business_class_seats, economy_class_seats, &#10;                                 manufacturing_year, last_maintenance, status)&#10;            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)&#10;            RETURNING *&#10;        `;&#10;        const values = [&#10;            aircraft.airline_id,&#10;            aircraft.registration,&#10;            aircraft.aircraft_type,&#10;            aircraft.manufacturer,&#10;            aircraft.model,&#10;            aircraft.seat_capacity,&#10;            aircraft.business_class_seats,&#10;            aircraft.economy_class_seats,&#10;            aircraft.manufacturing_year,&#10;            aircraft.last_maintenance,&#10;            aircraft.status&#10;        ];&#10;        const result = await this.pool.query(query, values);&#10;        return result.rows[0];&#10;    }&#10;&#10;    // Voli&#10;    async getAllFlights(): Promise&lt;Flight[]&gt; {&#10;        try {&#10;            // Prima verifichiamo la struttura della tabella&#10;            const checkQuery = `&#10;                SELECT column_name, data_type &#10;                FROM information_schema.columns &#10;                WHERE table_name = 'flights'&#10;                ORDER BY ordinal_position&#10;            `;&#10;            const checkResult = await this.pool.query(checkQuery);&#10;            console.log('Columns in flights table:', checkResult.rows);&#10;&#10;            // Facciamo una query semplice prima&#10;            const simpleQuery = `SELECT * FROM flights LIMIT 1`;&#10;            const simpleResult = await this.pool.query(simpleQuery);&#10;            console.log('Sample flight data:', simpleResult.rows[0]);&#10;&#10;            const query = `&#10;                SELECT &#10;                    f.*,&#10;                    da.name as departure_airport_name,&#10;                    da.city as departure_city,&#10;                    aa.name as arrival_airport_name,&#10;                    aa.city as arrival_city,&#10;                    al.name as airline_name,&#10;                    al.iata_code as airline_code,&#10;                    ac.registration as aircraft_registration,&#10;                    ac.model as aircraft_model&#10;                FROM flights f&#10;                LEFT JOIN airports da ON f.departure_airport_id = da.id&#10;                LEFT JOIN airports aa ON f.arrival_airport_id = aa.id&#10;                LEFT JOIN airlines al ON f.airline_id = al.id&#10;                LEFT JOIN aircrafts ac ON f.aircraft_id = ac.id&#10;                ORDER BY f.departure_time ASC&#10;            `;&#10;            const result = await this.pool.query(query);&#10;            &#10;            // Mappiamo i risultati al formato atteso&#10;            return result.rows.map(row =&gt; ({&#10;                id: row.id,&#10;                flight_number: row.flight_number,&#10;                airline_id: row.airline_id,&#10;                aircraft_id: row.aircraft_id,&#10;                airline: row.airline_name || row.airline_code || 'N/A',&#10;                aircraft: row.aircraft_registration ? `${row.aircraft_model} (${row.aircraft_registration})` : 'N/A',&#10;                departure_airport: row.departure_airport_name || row.departure_airport || 'N/A',&#10;                departure_city: row.departure_city || 'N/A',&#10;                arrival_airport: row.arrival_airport_name || row.arrival_airport || 'N/A',&#10;                arrival_city: row.arrival_city || 'N/A',&#10;                departure_time: row.departure_time,&#10;                arrival_time: row.arrival_time,&#10;                price: row.price,&#10;                available_seats: row.available_seats || 0,&#10;                total_seats: row.total_seats || 0,&#10;                status: row.status,&#10;                created_at: row.created_at,&#10;                updated_at: row.updated_at&#10;            }));&#10;        } catch (error) {&#10;            console.error('Error in getAllFlights:', error);&#10;            throw error;&#10;        }&#10;    }&#10;&#10;    async getFlightById(id: number): Promise&lt;Flight | null&gt; {&#10;        const query = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;            WHERE f.id = $1&#10;        `;&#10;        const result = await this.pool.query(query, [id]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    async searchFlights(departureAirport: string, arrivalAirport: string, departureDate: string): Promise&lt;Flight[]&gt; {&#10;        const query = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;            WHERE da.name = $1 &#10;            AND aa.name = $2 &#10;            AND DATE(f.departure_time) = $3&#10;            AND f.status = 'scheduled'&#10;            AND f.available_seats &gt; 0&#10;            ORDER BY f.departure_time ASC&#10;        `;&#10;        const result = await this.pool.query(query, [departureAirport, arrivalAirport, departureDate]);&#10;        const appo='s';&#10;        return result.rows; &#10;    }&#10;&#10;    // Prenotazioni&#10;    async createBooking(booking: Omit&lt;Booking, 'id' | 'created_at' | 'updated_at'&gt;): Promise&lt;Booking&gt; {&#10;        const query = `&#10;            INSERT INTO bookings (user_id, flight_id, booking_reference, passenger_count, total_price, status)&#10;            VALUES ($1, $2, $3, $4, $5, $6)&#10;            RETURNING *&#10;        `;&#10;        const values = [&#10;            booking.user_id,&#10;            booking.flight_id,&#10;            booking.booking_reference,&#10;            booking.passenger_count,&#10;            booking.total_price,&#10;            booking.status&#10;        ];&#10;        const result = await this.pool.query(query, values);&#10;        return result.rows[0];&#10;    }&#10;&#10;    async getBookingsByUserId(userId: number): Promise&lt;Booking[]&gt; {&#10;        const query = `&#10;            SELECT b.*, f.flight_number, f.airline, f.departure_airport, f.arrival_airport, &#10;                   f.departure_time, f.arrival_time&#10;            FROM bookings b&#10;            JOIN flights f ON b.flight_id = f.id&#10;            WHERE b.user_id = $1&#10;            ORDER BY b.created_at DESC&#10;        `;&#10;        const result = await this.pool.query(query, [userId]);&#10;        return result.rows;&#10;    }&#10;&#10;    async getBookingByReference(reference: string): Promise&lt;Booking | null&gt; {&#10;        const query = 'SELECT * FROM bookings WHERE booking_reference = $1';&#10;        const result = await this.pool.query(query, [reference]);&#10;        return result.rows[0] || null;&#10;    }&#10;&#10;    // Utility per aggiornare i posti disponibili&#10;    async updateFlightSeats(flightId: number, seatChange: number): Promise&lt;void&gt; {&#10;        const query = `&#10;            UPDATE flights &#10;            SET available_seats = available_seats + $1,&#10;                updated_at = CURRENT_TIMESTAMP&#10;            WHERE id = $2&#10;        `;&#10;        await this.pool.query(query, [seatChange, flightId]);&#10;    }&#10;&#10;    // Metodi per supportare i filtri del frontend&#10;    async getActiveFlights(): Promise&lt;Flight[]&gt; {&#10;        const query = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;            WHERE f.status IN ('scheduled', 'delayed') &#10;            ORDER BY f.departure_time ASC&#10;        `;&#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    async getOnTimeFlights(): Promise&lt;Flight[]&gt; {&#10;        const query = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;            WHERE f.status = 'scheduled'&#10;            ORDER BY f.departure_time ASC&#10;        `;&#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    async filterFlights(filterType: 'all' | 'departures' | 'arrivals'): Promise&lt;Flight[]&gt; {&#10;        let query: string;&#10;        &#10;        const baseQuery = `&#10;            SELECT &#10;                f.id,&#10;                f.flight_number,&#10;                SUBSTRING(f.flight_number, 1, 2) as airline,&#10;                da.name as departure_airport,&#10;                aa.name as arrival_airport,&#10;                f.departure_time,&#10;                f.arrival_time,&#10;                f.price,&#10;                f.available_seats,&#10;                f.total_seats,&#10;                f.status,&#10;                f.created_at,&#10;                f.updated_at&#10;            FROM flights f&#10;            JOIN airports da ON f.departure_airport_id = da.id&#10;            JOIN airports aa ON f.arrival_airport_id = aa.id&#10;        `;&#10;        &#10;        switch (filterType) {&#10;            case 'departures':&#10;                query = baseQuery + `&#10;                    WHERE f.departure_time::date = CURRENT_DATE&#10;                    ORDER BY f.departure_time ASC&#10;                `;&#10;                break;&#10;            case 'arrivals':&#10;                query = baseQuery + `&#10;                    WHERE f.arrival_time::date = CURRENT_DATE&#10;                    ORDER BY f.arrival_time ASC&#10;                `;&#10;                break;&#10;            default: // 'all'&#10;                query = baseQuery + ' ORDER BY f.departure_time ASC';&#10;        }&#10;        &#10;        const result = await this.pool.query(query);&#10;        return result.rows;&#10;    }&#10;&#10;    // Query personalizzate&#10;    async executeQuery(query: string, values?: any[]): Promise&lt;QueryResult&gt; {&#10;        return await this.pool.query(query, values);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/routes/admin.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/routes/admin.ts" />
              <option name="originalContent" value="import { Router } from 'express';&#10;import { DatabaseService } from '../models/database';&#10;import pool from '../db/pool';&#10;import { authenticateToken, verifyRole } from '../middleware/auth';&#10;import bcrypt from 'bcryptjs';&#10;&#10;const router = Router();&#10;const db = new DatabaseService(pool);&#10;&#10;// List all users (admin only)&#10;router.get('/users', authenticateToken, verifyRole('admin'), async (_req, res) =&gt; {&#10;    const users = await db.getAllUsers();&#10;    res.json(users);&#10;});&#10;&#10;// Invite/create airline user (admin only)&#10;router.post('/users/airline', authenticateToken, verifyRole('admin'), async (req, res) =&gt; {&#10;    const { email, airline_id } = req.body;&#10;    const tempPassword = Math.random().toString(36).slice(-8);&#10;    const password_hash = await bcrypt.hash(tempPassword, 10);&#10;    const now = new Date();&#10;&#10;    const airlineQuery = 'SELECT id, name FROM airlines WHERE id = $1 AND active = true';&#10;    const airlineResult = await pool.query(airlineQuery, [airline_id]);&#10;&#10;    if (airlineResult.rows.length === 0)&#10;        return res.status(404).json({ error: 'Compagnia aerea non trovata' });&#10;&#10;    const user = await db.createUser({&#10;        email,&#10;        password_hash,&#10;        first_name: null,&#10;        last_name : null,&#10;        phone : null,&#10;        role: 'airlines',&#10;        temporary_password: true,&#10;        created_at: now,&#10;        updated_at: now&#10;    });&#10;    // in real app send email with tempPassword&#10;    res.status(201).json({ user, temporary_password: tempPassword });&#10;});&#10;&#10;router.get('/airlines-available', authenticateToken, verifyRole('admin'), async (_req, res) =&gt; {&#10;    const query = `&#10;        SELECT a.id, a.name, a.iata_code,&#10;               CASE WHEN u.id IS NULL THEN false ELSE true END as has_admin&#10;        FROM airlines a&#10;        LEFT JOIN users u ON a.id = u.airline_id&#10;        WHERE a.active = true&#10;        ORDER BY a.name&#10;    `;&#10;    const result = await pool.query(query);&#10;    res.json(result.rows);&#10;});&#10;&#10;// Delete user by ID (admin only)&#10;router.delete('/users/:id', authenticateToken, verifyRole('admin'), async (req, res) =&gt; {&#10;    const id = parseInt(req.params.id, 10);&#10;    await db.deleteUserById(id);&#10;    res.sendStatus(204);&#10;});&#10;&#10;export default router;&#10;// end of file&#10;" />
              <option name="updatedContent" value="import { Router } from 'express';&#10;import { DatabaseService } from '../models/database';&#10;import pool from '../db/pool';&#10;import { authenticateToken, verifyRole } from '../middleware/auth';&#10;import bcrypt from 'bcryptjs';&#10;import crypto from 'crypto';&#10;&#10;const router = Router();&#10;const db = new DatabaseService(pool);&#10;&#10;// List all users (admin only)&#10;router.get('/users', authenticateToken, verifyRole('admin'), async (_req, res) =&gt; {&#10;    try {&#10;        const users = await db.getAllUsers();&#10;        res.json(users);&#10;    } catch (error) {&#10;        console.error('[ERROR] Failed to get users:', error);&#10;        res.status(500).json({ error: 'Errore nel recupero degli utenti' });&#10;    }&#10;});&#10;&#10;// List all airlines for invitation (admin only)&#10;router.get('/airlines-available', authenticateToken, verifyRole('admin'), async (_req, res) =&gt; {&#10;    try {&#10;        const query = `&#10;            SELECT a.id, a.name, a.iata_code, a.country,&#10;                   CASE WHEN u.id IS NULL THEN false ELSE true END as has_admin&#10;            FROM airlines a&#10;            LEFT JOIN users u ON a.id = u.airline_id AND u.role = 'airline_admin'&#10;            WHERE a.active = true&#10;            ORDER BY a.name&#10;        `;&#10;        &#10;        const result = await pool.query(query);&#10;        res.json(result.rows);&#10;    } catch (error) {&#10;        console.error('[ERROR] Failed to get available airlines:', error);&#10;        res.status(500).json({ error: 'Errore nel recupero delle compagnie aeree' });&#10;    }&#10;});&#10;&#10;// Invite/create airline user (admin only)&#10;router.post('/invite-airline', authenticateToken, verifyRole('admin'), async (req, res) =&gt; {&#10;    try {&#10;        const { airline_id, email, first_name, last_name, phone } = req.body;&#10;&#10;        // Verifica che la compagnia aerea esista&#10;        const airlineQuery = 'SELECT id, name, iata_code FROM airlines WHERE id = $1 AND active = true';&#10;        const airlineResult = await pool.query(airlineQuery, [airline_id]);&#10;        &#10;        if (airlineResult.rows.length === 0) {&#10;            return res.status(404).json({ error: 'Compagnia aerea non trovata o non attiva' });&#10;        }&#10;&#10;        const airline = airlineResult.rows[0];&#10;&#10;        // Verifica che non esista già un admin per questa compagnia&#10;        const existingAdminQuery = 'SELECT id FROM users WHERE airline_id = $1 AND role = $2';&#10;        const existingAdmin = await pool.query(existingAdminQuery, [airline_id, 'airline_admin']);&#10;        &#10;        if (existingAdmin.rows.length &gt; 0) {&#10;            return res.status(400).json({ &#10;                error: `La compagnia ${airline.name} ha già un amministratore assegnato` &#10;            });&#10;        }&#10;&#10;        // Verifica che l'email non sia già in uso&#10;        const existingUserQuery = 'SELECT id FROM users WHERE email = $1';&#10;        const existingUser = await pool.query(existingUserQuery, [email]);&#10;        &#10;        if (existingUser.rows.length &gt; 0) {&#10;            return res.status(400).json({ error: 'Email già in uso' });&#10;        }&#10;&#10;        // Genera password temporanea sicura (12 caratteri)&#10;        const tempPassword = crypto.randomBytes(8).toString('hex');&#10;        const passwordHash = await bcrypt.hash(tempPassword, 10);&#10;        const now = new Date();&#10;&#10;        // Crea l'utente admin della compagnia aerea usando il metodo esistente&#10;        const user = await db.createUser({&#10;            email,&#10;            password_hash: passwordHash,&#10;            first_name: first_name || 'Admin',&#10;            last_name: last_name || airline.name,&#10;            phone: phone || '',&#10;            role: 'airline_admin', // Corretto da 'airlines' a 'airline_admin'&#10;            airline_id: airline_id, // Aggiunto campo mancante&#10;            temporary_password: true,&#10;            created_at: now,&#10;            updated_at: now&#10;        });&#10;&#10;        console.log(`[INFO] Airline admin invited for ${airline.name}:`, {&#10;            userId: user.id,&#10;            email: user.email,&#10;            airlineId: airline_id,&#10;            airlineName: airline.name&#10;        });&#10;&#10;        res.status(201).json({&#10;            message: `Amministratore per ${airline.name} invitato con successo`,&#10;            user: {&#10;                id: user.id,&#10;                email: user.email,&#10;                first_name: user.first_name,&#10;                last_name: user.last_name,&#10;                role: user.role,&#10;                airline: {&#10;                    id: airline.id,&#10;                    name: airline.name,&#10;                    code: airline.iata_code&#10;                }&#10;            },&#10;            temporary_password: tempPassword, // In produzione, inviare via email sicura&#10;            instructions: 'La password temporanea deve essere cambiata al primo login'&#10;        });&#10;&#10;    } catch (error) {&#10;        console.error('[ERROR] Failed to invite airline admin:', error);&#10;        res.status(500).json({ error: 'Errore nella creazione dell\'invito' });&#10;    }&#10;});&#10;&#10;// Delete user (admin only)&#10;router.delete('/users/:id', authenticateToken, verifyRole('admin'), async (req, res) =&gt; {&#10;    try {&#10;        const { id } = req.params;&#10;        &#10;        // Verifica che l'utente non sia l'admin principale&#10;        const userQuery = 'SELECT role, email FROM users WHERE id = $1';&#10;        const userResult = await pool.query(userQuery, [id]);&#10;        &#10;        if (userResult.rows.length === 0) {&#10;            return res.status(404).json({ error: 'Utente non trovato' });&#10;        }&#10;        &#10;        const user = userResult.rows[0];&#10;        if (user.role === 'admin') {&#10;            return res.status(403).json({ error: 'Non è possibile eliminare l\'amministratore principale' });&#10;        }&#10;&#10;        // Controlla se ci sono prenotazioni associate&#10;        const bookingsCheck = await pool.query(&#10;            'SELECT COUNT(*) as count FROM bookings WHERE user_id = $1',&#10;            [id]&#10;        );&#10;        &#10;        if (parseInt(bookingsCheck.rows[0].count) &gt; 0) {&#10;            return res.status(400).json({ &#10;                error: 'Impossibile eliminare: esistono prenotazioni associate' &#10;            });&#10;        }&#10;        &#10;        const deleteResult = await pool.query('DELETE FROM users WHERE id = $1 RETURNING *', [id]);&#10;        &#10;        res.json({ &#10;            message: 'Utente eliminato con successo', &#10;            user: deleteResult.rows[0] &#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Failed to delete user:', error);&#10;        res.status(500).json({ error: 'Errore nell\'eliminazione dell\'utente' });&#10;    }&#10;});&#10;&#10;export default router;&#10;// end of file" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/routes/aircrafts.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/routes/aircrafts.ts" />
              <option name="originalContent" value="import express from 'express';&#10;import { DatabaseService } from '../models/database';&#10;import { Pool } from 'pg';&#10;import { authenticateToken, verifyAirlineAdmin, verifyAirlineAccess, verifyAdminOrAirlineAdmin, AuthRequest } from '../middleware/auth';&#10;&#10;const router = express.Router();&#10;&#10;// Connessione al database&#10;const pool = new Pool({&#10;  connectionString: process.env.DATABASE_URL&#10;});&#10;&#10;const dbService = new DatabaseService(pool);&#10;&#10;// API Aerei - Lista tutti gli aerei (admin generale) o della propria compagnia (admin airline)&#10;router.get('/', authenticateToken, verifyAdminOrAirlineAdmin, async (req: AuthRequest, res: express.Response) =&gt; {&#10;  console.log('[DEBUG] Aircrafts GET / route called');&#10;  try {&#10;      let aircrafts;&#10;&#10;      if (req.userRole === 'admin') {&#10;          // Super admin vede tutti gli aerei&#10;          aircrafts = await dbService.getAllAircrafts();&#10;          console.log('[DEBUG] Super admin - showing all aircrafts');&#10;      } else if (req.userRole === 'airline_admin' &amp;&amp; req.airlineId) {&#10;          // Admin compagnia vede solo i suoi aerei&#10;          aircrafts = await dbService.getAircraftsByAirline(req.airlineId);&#10;          console.log('[DEBUG] Airline admin - showing aircrafts for airline:', req.airlineId);&#10;      } else {&#10;          return res.status(403).json({ error: 'Accesso non autorizzato' });&#10;      }&#10;&#10;      res.json(aircrafts);&#10;  } catch (error) {&#10;      console.error('[ERROR] Error fetching aircrafts:', error);&#10;      res.status(500).json({&#10;            error: 'Errore durante il recupero degli aerei',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Ottieni aerei della mia compagnia (solo admin compagnie)&#10;router.get('/my-aircrafts', authenticateToken, verifyAirlineAdmin, async (req: AuthRequest, res: express.Response) =&gt; {&#10;    console.log('[DEBUG] GET /my-aircrafts called for airline:', req.airlineId);&#10;    try {&#10;        if (!req.airlineId) {&#10;            return res.status(400).json({ error: 'ID compagnia mancante' });&#10;        }&#10;&#10;        const aircrafts = await dbService.getAircraftsByAirline(req.airlineId);&#10;&#10;        // Aggiungi statistiche per ogni aereo&#10;        const aircraftsWithStats = await Promise.all(aircrafts.map(async (aircraft) =&gt; {&#10;            const flightsQuery = `&#10;                SELECT COUNT(*) as total_flights,&#10;                       COUNT(CASE WHEN status = 'scheduled' THEN 1 END) as scheduled_flights,&#10;                       MAX(departure_time) as last_flight&#10;                FROM flights &#10;                WHERE aircraft_id = $1&#10;            `;&#10;            const flightStats = await pool.query(flightsQuery, [aircraft.id]);&#10;&#10;            return {&#10;                ...aircraft,&#10;                stats: {&#10;                    total_flights: parseInt(flightStats.rows[0].total_flights),&#10;                    scheduled_flights: parseInt(flightStats.rows[0].scheduled_flights),&#10;                    last_flight: flightStats.rows[0].last_flight&#10;                }&#10;            };&#10;        }));&#10;&#10;        res.json({&#10;            airline: {&#10;                id: req.airlineId,&#10;                name: req.airlineName&#10;            },&#10;            aircrafts: aircraftsWithStats,&#10;            total: aircraftsWithStats.length&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error fetching my aircrafts:', error);&#10;        res.status(500).json({&#10;            error: 'Errore durante il recupero degli aerei della compagnia',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Ottieni dettagli aereo specifico&#10;router.get('/:id', authenticateToken, verifyAdminOrAirlineAdmin, async (req: AuthRequest, res: express.Response) =&gt; {&#10;  console.log('[DEBUG] Aircrafts GET /:id route called with id:', req.params.id);&#10;  try {&#10;      const { id } = req.params;&#10;      const aircraft = await dbService.getAircraftById(parseInt(id));&#10;&#10;      if (!aircraft) {&#10;          return res.status(404).json({ error: 'Aereo non trovato' });&#10;      }&#10;&#10;      // Verifica che l'admin della compagnia possa accedere solo ai suoi aerei&#10;      if (req.userRole === 'airline_admin' &amp;&amp; aircraft.airline_id !== req.airlineId) {&#10;          return res.status(403).json({ error: 'Non puoi accedere a questo aereo' });&#10;      }&#10;&#10;      // Aggiungi statistiche dell'aereo&#10;      const flightsQuery = `&#10;          SELECT COUNT(*) as total_flights,&#10;                 COUNT(CASE WHEN status = 'scheduled' THEN 1 END) as scheduled_flights,&#10;                 COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_flights,&#10;                 AVG(CASE WHEN status = 'completed' THEN (total_seats - available_seats) END) as avg_passengers&#10;          FROM flights &#10;          WHERE aircraft_id = $1&#10;      `;&#10;      const flightStats = await pool.query(flightsQuery, [id]);&#10;&#10;      const recentFlightsQuery = `&#10;          SELECT f.flight_number, f.departure_time, f.arrival_time, f.status,&#10;                 da.name as departure_airport, aa.name as arrival_airport&#10;          FROM flights f&#10;          JOIN airports da ON f.departure_airport_id = da.id&#10;          JOIN airports aa ON f.arrival_airport_id = aa.id&#10;          WHERE f.aircraft_id = $1&#10;          ORDER BY f.departure_time DESC&#10;          LIMIT 5&#10;      `;&#10;      const recentFlights = await pool.query(recentFlightsQuery, [id]);&#10;&#10;      res.json({&#10;          ...aircraft,&#10;          stats: {&#10;              total_flights: parseInt(flightStats.rows[0].total_flights),&#10;              scheduled_flights: parseInt(flightStats.rows[0].scheduled_flights),&#10;              completed_flights: parseInt(flightStats.rows[0].completed_flights),&#10;              avg_passengers: parseFloat(flightStats.rows[0].avg_passengers) || 0&#10;          },&#10;          recent_flights: recentFlights.rows&#10;      });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error fetching aircraft:', error);&#10;        res.status(500).json({&#10;            error: 'Errore durante il recupero dell\'aereo',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Crea nuovo aereo (solo admin compagnie per la propria compagnia)&#10;router.post('/', authenticateToken, verifyAirlineAdmin, async (req: AuthRequest, res: express.Response) =&gt; {&#10;    console.log('[DEBUG] POST /aircrafts called for airline:', req.airlineId);&#10;    try {&#10;        const { registration, aircraft_type, manufacturer, model, seat_capacity, business_class_seats, economy_class_seats, manufacturing_year } = req.body;&#10;&#10;        // Validazioni&#10;        if (!registration || !aircraft_type || !manufacturer || !model || !seat_capacity) {&#10;            return res.status(400).json({&#10;                error: 'Campi obbligatori mancanti: registration, aircraft_type, manufacturer, model, seat_capacity'&#10;            });&#10;        }&#10;&#10;        if (business_class_seats + economy_class_seats !== seat_capacity) {&#10;            return res.status(400).json({&#10;                error: 'La somma dei posti business e economy deve essere uguale alla capacità totale'&#10;            });&#10;        }&#10;&#10;        // Verifica che la registrazione sia unica&#10;        const existingAircraft = await pool.query(&#10;            'SELECT id FROM aircrafts WHERE registration = $1',&#10;            [registration]&#10;        );&#10;&#10;        if (existingAircraft.rows.length &gt; 0) {&#10;            return res.status(400).json({ error: 'Registrazione aereo già esistente' });&#10;        }&#10;&#10;        const aircraftData = {&#10;            airline_id: req.airlineId!, // Automaticamente della compagnia dell'admin&#10;            registration,&#10;            aircraft_type,&#10;            manufacturer,&#10;            model,&#10;            seat_capacity: parseInt(seat_capacity),&#10;            business_class_seats: parseInt(business_class_seats) || 0,&#10;            economy_class_seats: parseInt(economy_class_seats),&#10;            manufacturing_year: manufacturing_year ? parseInt(manufacturing_year) : undefined,&#10;            last_maintenance: undefined,&#10;            status: 'active' as const,&#10;            created_at: new Date(),&#10;            updated_at: new Date()&#10;        };&#10;&#10;        const aircraft = await dbService.createAircraft(aircraftData);&#10;&#10;        console.log('[INFO] Aircraft created:', {&#10;            id: aircraft.id,&#10;            registration: aircraft.registration,&#10;            airline_id: req.airlineId,&#10;            airline_name: req.airlineName&#10;        });&#10;&#10;        res.status(201).json({&#10;            message: 'Aereo creato con successo',&#10;            aircraft: {&#10;                ...aircraft,&#10;                airline_name: req.airlineName&#10;            }&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error creating aircraft:', error);&#10;        res.status(500).json({&#10;            error: 'Errore durante la creazione dell\'aereo',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Aggiorna aereo esistente&#10;router.put('/:id', authenticateToken, verifyAirlineAdmin, async (req: AuthRequest, res: express.Response) =&gt; {&#10;    try {&#10;        const { id } = req.params;&#10;        const { registration, aircraft_type, manufacturer, model, seat_capacity, business_class_seats, economy_class_seats, manufacturing_year, status } = req.body;&#10;&#10;        // Verifica che l'aereo appartenga alla compagnia dell'admin&#10;        const aircraft = await dbService.getAircraftById(parseInt(id));&#10;        if (!aircraft) {&#10;            return res.status(404).json({ error: 'Aereo non trovato' });&#10;        }&#10;&#10;        if (aircraft.airline_id !== req.airlineId) {&#10;            return res.status(403).json({ error: 'Non puoi modificare questo aereo' });&#10;        }&#10;&#10;        // Validazioni se i campi sono forniti&#10;        if (business_class_seats !== undefined &amp;&amp; economy_class_seats !== undefined &amp;&amp; seat_capacity !== undefined) {&#10;            if (business_class_seats + economy_class_seats !== seat_capacity) {&#10;                return res.status(400).json({&#10;                    error: 'La somma dei posti business e economy deve essere uguale alla capacità totale'&#10;                });&#10;            }&#10;        }&#10;&#10;        const updateQuery = `&#10;            UPDATE aircrafts &#10;            SET registration = COALESCE($1, registration),&#10;                aircraft_type = COALESCE($2, aircraft_type),&#10;                manufacturer = COALESCE($3, manufacturer),&#10;                model = COALESCE($4, model),&#10;                seat_capacity = COALESCE($5, seat_capacity),&#10;                business_class_seats = COALESCE($6, business_class_seats),&#10;                economy_class_seats = COALESCE($7, economy_class_seats),&#10;                manufacturing_year = COALESCE($8, manufacturing_year),&#10;                status = COALESCE($9, status),&#10;                updated_at = CURRENT_TIMESTAMP&#10;            WHERE id = $10&#10;            RETURNING *&#10;        `;&#10;&#10;        const values = [&#10;            registration, aircraft_type, manufacturer, model,&#10;            seat_capacity, business_class_seats, economy_class_seats,&#10;            manufacturing_year, status, id&#10;        ];&#10;&#10;        const result = await pool.query(updateQuery, values);&#10;&#10;        res.json({&#10;            message: 'Aereo aggiornato con successo',&#10;            aircraft: result.rows[0]&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error updating aircraft:', error);&#10;        res.status(500).json({&#10;            error: 'Errore durante l\'aggiornamento dell\'aereo',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Elimina aereo&#10;router.delete('/:id', authenticateToken, verifyAirlineAdmin, async (req: AuthRequest, res: express.Response) =&gt; {&#10;    try {&#10;        const { id } = req.params;&#10;&#10;        // Verifica che l'aereo appartenga alla compagnia dell'admin&#10;        const aircraft = await dbService.getAircraftById(parseInt(id));&#10;        if (!aircraft) {&#10;            return res.status(404).json({ error: 'Aereo non trovato' });&#10;        }&#10;&#10;        if (aircraft.airline_id !== req.airlineId) {&#10;            return res.status(403).json({ error: 'Non puoi eliminare questo aereo' });&#10;        }&#10;&#10;        // Controlla se ci sono voli associati&#10;        const flightsCheck = await pool.query(&#10;            'SELECT COUNT(*) as count FROM flights WHERE aircraft_id = $1',&#10;            [id]&#10;        );&#10;&#10;        if (parseInt(flightsCheck.rows[0].count) &gt; 0) {&#10;            return res.status(400).json({&#10;                error: 'Impossibile eliminare: esistono voli associati a questo aereo'&#10;            });&#10;        }&#10;&#10;        const result = await pool.query('DELETE FROM aircrafts WHERE id = $1 RETURNING *', [id]);&#10;&#10;        res.json({&#10;            message: 'Aereo eliminato con successo',&#10;            aircraft: result.rows[0]&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error deleting aircraft:', error);&#10;        res.status(500).json({&#10;            error: 'Errore nell\'eliminazione dell\'aereo',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;export default router;&#10;" />
              <option name="updatedContent" value="import express, { Request, Response } from 'express';&#10;import { DatabaseService } from '../models/database';&#10;import { Pool } from 'pg';&#10;import { authenticateToken, verifyAirlineAdmin, verifyAirlineAccess, verifyAdminOrAirlineAdmin, AuthRequest } from '../middleware/auth';&#10;&#10;const router = express.Router();&#10;&#10;// Connessione al database&#10;const pool = new Pool({&#10;  connectionString: process.env.DATABASE_URL&#10;});&#10;&#10;const dbService = new DatabaseService(pool);&#10;&#10;// API Aerei - Lista tutti gli aerei (admin generale) o della propria compagnia (admin airline)&#10;router.get('/', authenticateToken, verifyAdminOrAirlineAdmin, async (req: AuthRequest, res: Response) =&gt; {&#10;  console.log('[DEBUG] Aircrafts GET / route called');&#10;  try {&#10;      let aircrafts;&#10;&#10;      if (req.userRole === 'admin') {&#10;          // Super admin vede tutti gli aerei&#10;          aircrafts = await dbService.getAllAircrafts();&#10;          console.log('[DEBUG] Super admin - showing all aircrafts');&#10;      } else if (req.userRole === 'airline_admin' &amp;&amp; req.airlineId) {&#10;          // Admin compagnia vede solo i suoi aerei&#10;          aircrafts = await dbService.getAircraftsByAirline(req.airlineId);&#10;          console.log('[DEBUG] Airline admin - showing aircrafts for airline:', req.airlineId);&#10;      } else {&#10;          return res.status(403).json({ error: 'Accesso non autorizzato' });&#10;      }&#10;&#10;      res.json(aircrafts);&#10;  } catch (error) {&#10;      console.error('[ERROR] Error fetching aircrafts:', error);&#10;      res.status(500).json({&#10;            error: 'Errore durante il recupero degli aerei',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Ottieni aerei della mia compagnia (solo admin compagnie)&#10;router.get('/my-aircrafts', authenticateToken, verifyAirlineAdmin, async (req: AuthRequest, res: Response) =&gt; {&#10;    console.log('[DEBUG] GET /my-aircrafts called for airline:', req.airlineId);&#10;    try {&#10;        if (!req.airlineId) {&#10;            return res.status(400).json({ error: 'ID compagnia mancante' });&#10;        }&#10;&#10;        const aircrafts = await dbService.getAircraftsByAirline(req.airlineId);&#10;&#10;        // Aggiungi statistiche per ogni aereo&#10;        const aircraftsWithStats = await Promise.all(aircrafts.map(async (aircraft) =&gt; {&#10;            const flightsQuery = `&#10;                SELECT COUNT(*) as total_flights,&#10;                       COUNT(CASE WHEN status = 'scheduled' THEN 1 END) as scheduled_flights,&#10;                       MAX(departure_time) as last_flight&#10;                FROM flights &#10;                WHERE aircraft_id = $1&#10;            `;&#10;            const flightStats = await pool.query(flightsQuery, [aircraft.id]);&#10;&#10;            return {&#10;                ...aircraft,&#10;                stats: {&#10;                    total_flights: parseInt(flightStats.rows[0].total_flights),&#10;                    scheduled_flights: parseInt(flightStats.rows[0].scheduled_flights),&#10;                    last_flight: flightStats.rows[0].last_flight&#10;                }&#10;            };&#10;        }));&#10;&#10;        res.json({&#10;            airline: {&#10;                id: req.airlineId,&#10;                name: req.airlineName&#10;            },&#10;            aircrafts: aircraftsWithStats,&#10;            total: aircraftsWithStats.length&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error fetching my aircrafts:', error);&#10;        res.status(500).json({&#10;            error: 'Errore durante il recupero degli aerei della compagnia',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Ottieni dettagli aereo specifico&#10;router.get('/:id', authenticateToken, verifyAdminOrAirlineAdmin, async (req: AuthRequest, res: Response) =&gt; {&#10;  console.log('[DEBUG] Aircrafts GET /:id route called with id:', req.params.id);&#10;  try {&#10;      const { id } = req.params;&#10;      const aircraft = await dbService.getAircraftById(parseInt(id));&#10;&#10;      if (!aircraft) {&#10;          return res.status(404).json({ error: 'Aereo non trovato' });&#10;      }&#10;&#10;      // Verifica che l'admin della compagnia possa accedere solo ai suoi aerei&#10;      if (req.userRole === 'airline_admin' &amp;&amp; aircraft.airline_id !== req.airlineId) {&#10;          return res.status(403).json({ error: 'Non puoi accedere a questo aereo' });&#10;      }&#10;&#10;      // Aggiungi statistiche dell'aereo&#10;      const flightsQuery = `&#10;          SELECT COUNT(*) as total_flights,&#10;                 COUNT(CASE WHEN status = 'scheduled' THEN 1 END) as scheduled_flights,&#10;                 COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_flights,&#10;                 AVG(CASE WHEN status = 'completed' THEN (total_seats - available_seats) END) as avg_passengers&#10;          FROM flights &#10;          WHERE aircraft_id = $1&#10;      `;&#10;      const flightStats = await pool.query(flightsQuery, [id]);&#10;&#10;      const recentFlightsQuery = `&#10;          SELECT f.flight_number, f.departure_time, f.arrival_time, f.status,&#10;                 da.name as departure_airport, aa.name as arrival_airport&#10;          FROM flights f&#10;          JOIN airports da ON f.departure_airport_id = da.id&#10;          JOIN airports aa ON f.arrival_airport_id = aa.id&#10;          WHERE f.aircraft_id = $1&#10;          ORDER BY f.departure_time DESC&#10;          LIMIT 5&#10;      `;&#10;      const recentFlights = await pool.query(recentFlightsQuery, [id]);&#10;&#10;      res.json({&#10;          ...aircraft,&#10;          stats: {&#10;              total_flights: parseInt(flightStats.rows[0].total_flights),&#10;              scheduled_flights: parseInt(flightStats.rows[0].scheduled_flights),&#10;              completed_flights: parseInt(flightStats.rows[0].completed_flights),&#10;              avg_passengers: parseFloat(flightStats.rows[0].avg_passengers) || 0&#10;          },&#10;          recent_flights: recentFlights.rows&#10;      });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error fetching aircraft:', error);&#10;        res.status(500).json({&#10;            error: 'Errore durante il recupero dell\'aereo',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Crea nuovo aereo (solo admin compagnie per la propria compagnia)&#10;router.post('/', authenticateToken, verifyAirlineAdmin, async (req: AuthRequest, res: Response) =&gt; {&#10;    console.log('[DEBUG] POST /aircrafts called for airline:', req.airlineId);&#10;    try {&#10;        const { registration, aircraft_type, manufacturer, model, seat_capacity, business_class_seats, economy_class_seats, manufacturing_year } = req.body;&#10;&#10;        // Validazioni&#10;        if (!registration || !aircraft_type || !manufacturer || !model || !seat_capacity) {&#10;            return res.status(400).json({&#10;                error: 'Campi obbligatori mancanti: registration, aircraft_type, manufacturer, model, seat_capacity'&#10;            });&#10;        }&#10;&#10;        if (business_class_seats + economy_class_seats !== seat_capacity) {&#10;            return res.status(400).json({&#10;                error: 'La somma dei posti business e economy deve essere uguale alla capacità totale'&#10;            });&#10;        }&#10;&#10;        // Verifica che la registrazione sia unica&#10;        const existingAircraft = await pool.query(&#10;            'SELECT id FROM aircrafts WHERE registration = $1',&#10;            [registration]&#10;        );&#10;&#10;        if (existingAircraft.rows.length &gt; 0) {&#10;            return res.status(400).json({ error: 'Registrazione aereo già esistente' });&#10;        }&#10;&#10;        const aircraftData = {&#10;            airline_id: req.airlineId!, // Automaticamente della compagnia dell'admin&#10;            registration,&#10;            aircraft_type,&#10;            manufacturer,&#10;            model,&#10;            seat_capacity: parseInt(seat_capacity),&#10;            business_class_seats: parseInt(business_class_seats) || 0,&#10;            economy_class_seats: parseInt(economy_class_seats),&#10;            manufacturing_year: manufacturing_year ? parseInt(manufacturing_year) : undefined,&#10;            last_maintenance: undefined,&#10;            status: 'active' as const,&#10;            created_at: new Date(),&#10;            updated_at: new Date()&#10;        };&#10;&#10;        const aircraft = await dbService.createAircraft(aircraftData);&#10;&#10;        console.log('[INFO] Aircraft created:', {&#10;            id: aircraft.id,&#10;            registration: aircraft.registration,&#10;            airline_id: req.airlineId,&#10;            airline_name: req.airlineName&#10;        });&#10;&#10;        res.status(201).json({&#10;            message: 'Aereo creato con successo',&#10;            aircraft: {&#10;                ...aircraft,&#10;                airline_name: req.airlineName&#10;            }&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error creating aircraft:', error);&#10;        res.status(500).json({&#10;            error: 'Errore durante la creazione dell\'aereo',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Aggiorna aereo esistente&#10;router.put('/:id', authenticateToken, verifyAirlineAdmin, async (req: AuthRequest, res: Response) =&gt; {&#10;    try {&#10;        const { id } = req.params;&#10;        const { registration, aircraft_type, manufacturer, model, seat_capacity, business_class_seats, economy_class_seats, manufacturing_year, status } = req.body;&#10;&#10;        // Verifica che l'aereo appartenga alla compagnia dell'admin&#10;        const aircraft = await dbService.getAircraftById(parseInt(id));&#10;        if (!aircraft) {&#10;            return res.status(404).json({ error: 'Aereo non trovato' });&#10;        }&#10;&#10;        if (aircraft.airline_id !== req.airlineId) {&#10;            return res.status(403).json({ error: 'Non puoi modificare questo aereo' });&#10;        }&#10;&#10;        // Validazioni se i campi sono forniti&#10;        if (business_class_seats !== undefined &amp;&amp; economy_class_seats !== undefined &amp;&amp; seat_capacity !== undefined) {&#10;            if (business_class_seats + economy_class_seats !== seat_capacity) {&#10;                return res.status(400).json({&#10;                    error: 'La somma dei posti business e economy deve essere uguale alla capacità totale'&#10;                });&#10;            }&#10;        }&#10;&#10;        const updateQuery = `&#10;            UPDATE aircrafts &#10;            SET registration = COALESCE($1, registration),&#10;                aircraft_type = COALESCE($2, aircraft_type),&#10;                manufacturer = COALESCE($3, manufacturer),&#10;                model = COALESCE($4, model),&#10;                seat_capacity = COALESCE($5, seat_capacity),&#10;                business_class_seats = COALESCE($6, business_class_seats),&#10;                economy_class_seats = COALESCE($7, economy_class_seats),&#10;                manufacturing_year = COALESCE($8, manufacturing_year),&#10;                status = COALESCE($9, status),&#10;                updated_at = CURRENT_TIMESTAMP&#10;            WHERE id = $10&#10;            RETURNING *&#10;        `;&#10;&#10;        const values = [&#10;            registration, aircraft_type, manufacturer, model,&#10;            seat_capacity, business_class_seats, economy_class_seats,&#10;            manufacturing_year, status, id&#10;        ];&#10;&#10;        const result = await pool.query(updateQuery, values);&#10;&#10;        res.json({&#10;            message: 'Aereo aggiornato con successo',&#10;            aircraft: result.rows[0]&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error updating aircraft:', error);&#10;        res.status(500).json({&#10;            error: 'Errore durante l\'aggiornamento dell\'aereo',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;// Elimina aereo&#10;router.delete('/:id', authenticateToken, verifyAirlineAdmin, async (req: AuthRequest, res: Response) =&gt; {&#10;    try {&#10;        const { id } = req.params;&#10;&#10;        // Verifica che l'aereo appartenga alla compagnia dell'admin&#10;        const aircraft = await dbService.getAircraftById(parseInt(id));&#10;        if (!aircraft) {&#10;            return res.status(404).json({ error: 'Aereo non trovato' });&#10;        }&#10;&#10;        if (aircraft.airline_id !== req.airlineId) {&#10;            return res.status(403).json({ error: 'Non puoi eliminare questo aereo' });&#10;        }&#10;&#10;        // Controlla se ci sono voli associati&#10;        const flightsCheck = await pool.query(&#10;            'SELECT COUNT(*) as count FROM flights WHERE aircraft_id = $1',&#10;            [id]&#10;        );&#10;&#10;        if (parseInt(flightsCheck.rows[0].count) &gt; 0) {&#10;            return res.status(400).json({&#10;                error: 'Impossibile eliminare: esistono voli associati a questo aereo'&#10;            });&#10;        }&#10;&#10;        const result = await pool.query('DELETE FROM aircrafts WHERE id = $1 RETURNING *', [id]);&#10;&#10;        res.json({&#10;            message: 'Aereo eliminato con successo',&#10;            aircraft: result.rows[0]&#10;        });&#10;    } catch (error) {&#10;        console.error('[ERROR] Error deleting aircraft:', error);&#10;        res.status(500).json({&#10;            error: 'Errore nell\'eliminazione dell\'aereo',&#10;            message: error instanceof Error ? error.message : 'Unknown error'&#10;        });&#10;    }&#10;});&#10;&#10;export default router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/routes/users.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/routes/users.ts" />
              <option name="originalContent" value="import express from 'express';&#10;import { Pool } from 'pg';&#10;import bcrypt from 'bcryptjs';&#10;import jwt from 'jsonwebtoken';&#10;&#10;const router = express.Router();&#10;&#10;// Connessione al database&#10;const pool = new Pool({&#10;  connectionString: process.env.DATABASE_URL&#10;});&#10;&#10;const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-here';&#10;&#10;// Registrazione utente&#10;router.post('/register', async (req, res) =&gt; {&#10;  console.debug('[DEBUG] POST /register called with body:', req.body);&#10;  try {&#10;    const { first_name, last_name, email, password, phone } = req.body;&#10;&#10;    // Verifica se l'utente esiste già&#10;    const existingUser = await pool.query('SELECT id FROM users WHERE email = $1', [email]);&#10;    if (existingUser.rows.length &gt; 0) {&#10;      return res.status(400).json({ error: 'Utente già esistente con questa email' });&#10;    }&#10;&#10;    // Hash della password&#10;    const saltRounds = 10;&#10;    const hashedPassword = await bcrypt.hash(password, saltRounds);&#10;&#10;    const query = `&#10;      INSERT INTO users (first_name, last_name, email, password_hash, phone, role, temporary_password) &#10;      VALUES ($1, $2, $3, $4, $5, $6, $7) &#10;      RETURNING id, first_name, last_name, email, phone, role, created_at&#10;    `;&#10;    &#10;    const values = [first_name, last_name, email, hashedPassword, phone, 'user', false];&#10;    const result = await pool.query(query, values);&#10;    &#10;    console.debug('[DEBUG] User saved to DB:', result.rows[0]);&#10;    res.status(201).json({ &#10;      message: 'Registrazione utente completata', &#10;      user: result.rows[0] &#10;    });&#10;  } catch (err: any) {&#10;    console.error('[ERROR] Registration failed:', err);&#10;    res.status(400).json({ error: err.message || 'Errore durante la registrazione' });&#10;  }&#10;});&#10;&#10;// Login utente&#10;router.post('/login', async (req, res) =&gt; {&#10;  console.debug('[DEBUG] POST /login called with body:', req.body);&#10;  try {&#10;    const { email, password } = req.body;&#10;    console.debug('[DEBUG] Attempting login for email:', email);&#10;&#10;    const query = `&#10;        SELECT u.id, u.email, u.first_name, u.last_name, u.role, &#10;               u.password_hash, u.temporary_password, u.airline_id,&#10;               a.name as airline_name, a.iata_code&#10;        FROM users u &#10;        LEFT JOIN airlines a ON u.airline_id = a.id&#10;        WHERE u.email = $1`;&#10;    const result = await pool.query(query, [email]);&#10;    &#10;    if (result.rows.length === 0) {&#10;      console.warn('[WARN] User not found for email:', email);&#10;      return res.status(401).json({ error: 'Credenziali non valide' });&#10;    }&#10;&#10;    const user = result.rows[0];&#10;    &#10;    // Verifica password&#10;    const passwordMatch = await bcrypt.compare(password, user.password_hash);&#10;&#10;    if (!passwordMatch) {&#10;      console.warn('[WARN] Password mismatch for email:', email);&#10;      return res.status(401).json({ error: 'Credenziali non valide' });&#10;    }&#10;&#10;    // Genera JWT token&#10;    const token = jwt.sign(&#10;      {&#10;        id: user.id,&#10;        email: user.email,&#10;        role: user.role&#10;      },&#10;      process.env.JWT_SECRET as string,&#10;      { expiresIn: '24h' }&#10;    );&#10;&#10;    console.debug('[DEBUG] Login successful for user:', user.email);&#10;    res.json({&#10;      message: 'Login effettuato',&#10;      token,&#10;      user: {&#10;        id: user.id,&#10;        email: user.email,&#10;        first_name: user.first_name,&#10;        last_name: user.last_name,&#10;        role: user.role,&#10;        temporary_password: user.temporary_password&#10;      }&#10;    });&#10;  } catch (error) {&#10;    console.error('[ERROR] Login failed:', error);&#10;    res.status(500).json({ error: 'Errore interno del server' });&#10;  }&#10;});&#10;&#10;// Visualizza tutti gli utenti (solo per admin)&#10;router.get('/', async (req, res) =&gt; {&#10;  try {&#10;    const query = 'SELECT id, first_name, last_name, email, phone, role, created_at FROM users ORDER BY created_at DESC';&#10;    const result = await pool.query(query);&#10;    res.json(result.rows);&#10;  } catch (err) {&#10;    console.error('Error fetching users:', err);&#10;    res.status(500).json({ error: 'Errore nel recupero degli utenti' });&#10;  }&#10;});&#10;&#10;// Ottieni profilo utente per ID&#10;router.get('/:id', async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const query = 'SELECT id, first_name, last_name, email, phone, role, created_at FROM users WHERE id = $1';&#10;    const result = await pool.query(query, [id]);&#10;    &#10;    if (result.rows.length === 0) {&#10;      return res.status(404).json({ error: 'Utente non trovato' });&#10;    }&#10;    &#10;    res.json(result.rows[0]);&#10;  } catch (err) {&#10;    console.error('Error fetching user:', err);&#10;    res.status(500).json({ error: 'Errore nel recupero dell\'utente' });&#10;  }&#10;});&#10;&#10;// Aggiorna profilo utente&#10;router.put('/:id', async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { first_name, last_name, email, phone } = req.body;&#10;&#10;    const query = `&#10;      UPDATE users &#10;      SET first_name = $1, last_name = $2, email = $3, phone = $4, updated_at = CURRENT_TIMESTAMP&#10;      WHERE id = $5 &#10;      RETURNING id, first_name, last_name, email, phone, updated_at&#10;    `;&#10;    &#10;    const values = [first_name, last_name, email, phone, id];&#10;    const result = await pool.query(query, values);&#10;    &#10;    if (result.rows.length === 0) {&#10;      return res.status(404).json({ error: 'Utente non trovato' });&#10;    }&#10;    &#10;    res.json({ &#10;      message: 'Profilo aggiornato con successo', &#10;      user: result.rows[0] &#10;    });&#10;  } catch (err: any) {&#10;    console.error('Error updating user:', err);&#10;    if (err.code === '23505') { // Violazione vincolo univoco&#10;      res.status(400).json({ error: 'Email già esistente' });&#10;    } else {&#10;      res.status(400).json({ error: 'Errore nell\'aggiornamento del profilo' });&#10;    }&#10;  }&#10;});&#10;&#10;// Elimina utente&#10;router.delete('/:id', async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    &#10;    // Controlla se ci sono prenotazioni associate&#10;    const bookingsCheck = await pool.query(&#10;      'SELECT COUNT(*) as count FROM bookings WHERE user_id = $1',&#10;      [id]&#10;    );&#10;    &#10;    if (parseInt(bookingsCheck.rows[0].count) &gt; 0) {&#10;      return res.status(400).json({ &#10;        error: 'Impossibile eliminare l\'utente: esistono prenotazioni associate' &#10;      });&#10;    }&#10;    &#10;    const result = await pool.query('DELETE FROM users WHERE id = $1 RETURNING *', [id]);&#10;    &#10;    if (result.rows.length === 0) {&#10;      return res.status(404).json({ error: 'Utente non trovato' });&#10;    }&#10;    &#10;    res.json({ &#10;      message: 'Utente eliminato con successo', &#10;      user: result.rows[0] &#10;    });&#10;  } catch (err) {&#10;    console.error('Error deleting user:', err);&#10;    res.status(500).json({ error: 'Errore nell\'eliminazione dell\'utente' });&#10;  }&#10;});&#10;&#10;export default router;&#10;" />
              <option name="updatedContent" value="import express from 'express';&#10;import { Pool } from 'pg';&#10;import bcrypt from 'bcryptjs';&#10;import jwt from 'jsonwebtoken';&#10;&#10;const router = express.Router();&#10;&#10;// Interfaccia per JWT payload esteso&#10;interface ExtendedJWTPayload {&#10;  userId: number;&#10;  email: string;&#10;  role: string;&#10;  airlineId?: number;&#10;  airlineName?: string;&#10;}&#10;&#10;// Connessione al database&#10;const pool = new Pool({&#10;  connectionString: process.env.DATABASE_URL&#10;});&#10;&#10;const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-here';&#10;&#10;// Registrazione utente&#10;router.post('/register', async (req, res) =&gt; {&#10;  console.debug('[DEBUG] POST /register called with body:', req.body);&#10;  try {&#10;    const { first_name, last_name, email, password, phone } = req.body;&#10;&#10;    // Verifica se l'utente esiste già&#10;    const existingUser = await pool.query('SELECT id FROM users WHERE email = $1', [email]);&#10;    if (existingUser.rows.length &gt; 0) {&#10;      return res.status(400).json({ error: 'Utente già esistente con questa email' });&#10;    }&#10;&#10;    // Hash della password&#10;    const saltRounds = 10;&#10;    const hashedPassword = await bcrypt.hash(password, saltRounds);&#10;&#10;    const query = `&#10;      INSERT INTO users (first_name, last_name, email, password_hash, phone, role, temporary_password) &#10;      VALUES ($1, $2, $3, $4, $5, $6, $7) &#10;      RETURNING id, first_name, last_name, email, phone, role, created_at&#10;    `;&#10;    &#10;    const values = [first_name, last_name, email, hashedPassword, phone, 'user', false];&#10;    const result = await pool.query(query, values);&#10;    &#10;    console.debug('[DEBUG] User saved to DB:', result.rows[0]);&#10;    res.status(201).json({ &#10;      message: 'Registrazione utente completata', &#10;      user: result.rows[0] &#10;    });&#10;  } catch (err: any) {&#10;    console.error('[ERROR] Registration failed:', err);&#10;    res.status(400).json({ error: err.message || 'Errore durante la registrazione' });&#10;  }&#10;});&#10;&#10;// Login utente&#10;router.post('/login', async (req, res) =&gt; {&#10;  console.debug('[DEBUG] POST /login called with body:', req.body);&#10;  try {&#10;    const { email, password } = req.body;&#10;    console.debug('[DEBUG] Attempting login for email:', email);&#10;&#10;    const query = `&#10;        SELECT u.id, u.email, u.first_name, u.last_name, u.role, &#10;               u.password_hash, u.temporary_password, u.airline_id,&#10;               a.name as airline_name, a.iata_code&#10;        FROM users u &#10;        LEFT JOIN airlines a ON u.airline_id = a.id&#10;        WHERE u.email = $1`;&#10;    const result = await pool.query(query, [email]);&#10;    &#10;    if (result.rows.length === 0) {&#10;      console.warn('[WARN] User not found for email:', email);&#10;      return res.status(401).json({ error: 'Credenziali non valide' });&#10;    }&#10;&#10;    const user = result.rows[0];&#10;    &#10;    // Verifica password&#10;    const passwordMatch = await bcrypt.compare(password, user.password_hash);&#10;&#10;    if (!passwordMatch) {&#10;      console.warn('[WARN] Password mismatch for email:', email);&#10;      return res.status(401).json({ error: 'Credenziali non valide' });&#10;    }&#10;&#10;    // Genera JWT token payload&#10;    const tokenPayload: ExtendedJWTPayload = {&#10;      userId: user.id,&#10;      email: user.email,&#10;      role: user.role&#10;    };&#10;&#10;    // Se è un admin di compagnia aerea, aggiungere info airline&#10;    if (user.airline_id &amp;&amp; user.airline_name) {&#10;      tokenPayload.airlineId = user.airline_id;&#10;      tokenPayload.airlineName = user.airline_name;&#10;    }&#10;&#10;    // Controllare se deve cambiare password&#10;    if (user.temporary_password) {&#10;      const tempToken = jwt.sign(tokenPayload, process.env.JWT_SECRET as string, { expiresIn: '1h' });&#10;      return res.json({&#10;        message: 'Password temporanea - cambio richiesto',&#10;        requirePasswordChange: true,&#10;        token: tempToken&#10;      });&#10;    }&#10;&#10;    // Token normale per utenti con password definitiva&#10;    const token = jwt.sign(tokenPayload, process.env.JWT_SECRET as string, { expiresIn: '24h' });&#10;&#10;    console.debug('[DEBUG] Login successful for user:', user.email);&#10;    res.json({&#10;      message: 'Login effettuato',&#10;      token,&#10;      user: {&#10;        id: user.id,&#10;        email: user.email,&#10;        first_name: user.first_name,&#10;        last_name: user.last_name,&#10;        role: user.role,&#10;        temporary_password: user.temporary_password,&#10;        airline: user.airline_id ? {&#10;          id: user.airline_id,&#10;          name: user.airline_name,&#10;          code: user.iata_code&#10;        } : null&#10;      }&#10;    });&#10;  } catch (error) {&#10;    console.error('[ERROR] Login failed:', error);&#10;    res.status(500).json({ error: 'Errore interno del server' });&#10;  }&#10;});&#10;&#10;// Cambio password per primo login (compagnie aeree)&#10;router.post('/change-password', async (req, res) =&gt; {&#10;  try {&#10;    const { currentPassword, newPassword } = req.body;&#10;    const authHeader = req.headers['authorization'];&#10;    const token = authHeader &amp;&amp; authHeader.split(' ')[1];&#10;&#10;    if (!token) {&#10;      return res.status(401).json({ error: 'Token mancante' });&#10;    }&#10;&#10;    const payload = jwt.verify(token, process.env.JWT_SECRET as string) as ExtendedJWTPayload;&#10;&#10;    // Verifica password attuale&#10;    const userQuery = 'SELECT password_hash FROM users WHERE id = $1 AND temporary_password = true';&#10;    const userResult = await pool.query(userQuery, [payload.userId]);&#10;    &#10;    if (userResult.rows.length === 0) {&#10;      return res.status(404).json({ error: 'Utente non trovato o password già cambiata' });&#10;    }&#10;&#10;    const passwordMatch = await bcrypt.compare(currentPassword, userResult.rows[0].password_hash);&#10;    if (!passwordMatch) {&#10;      return res.status(401).json({ error: 'Password attuale non corretta' });&#10;    }&#10;&#10;    // Aggiorna password&#10;    const hashedNewPassword = await bcrypt.hash(newPassword, 10);&#10;    await pool.query(&#10;      'UPDATE users SET password_hash = $1, temporary_password = false, updated_at = CURRENT_TIMESTAMP WHERE id = $2',&#10;      [hashedNewPassword, payload.userId]&#10;    );&#10;&#10;    // Genera nuovo token completo&#10;    const newToken = jwt.sign(payload, process.env.JWT_SECRET as string, { expiresIn: '24h' });&#10;&#10;    res.json({&#10;      message: 'Password cambiata con successo',&#10;      token: newToken&#10;    });&#10;&#10;  } catch (error) {&#10;    console.error('[ERROR] Password change failed:', error);&#10;    if (error instanceof jwt.JsonWebTokenError) {&#10;      res.status(403).json({ error: 'Token non valido' });&#10;    } else {&#10;      res.status(500).json({ error: 'Errore interno del server' });&#10;    }&#10;  }&#10;});&#10;&#10;// Visualizza tutti gli utenti (solo per admin)&#10;router.get('/', async (req, res) =&gt; {&#10;  try {&#10;    const query = 'SELECT id, first_name, last_name, email, phone, role, created_at FROM users ORDER BY created_at DESC';&#10;    const result = await pool.query(query);&#10;    res.json(result.rows);&#10;  } catch (err) {&#10;    console.error('Error fetching users:', err);&#10;    res.status(500).json({ error: 'Errore nel recupero degli utenti' });&#10;  }&#10;});&#10;&#10;// Ottieni profilo utente per ID&#10;router.get('/:id', async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const query = 'SELECT id, first_name, last_name, email, phone, role, created_at FROM users WHERE id = $1';&#10;    const result = await pool.query(query, [id]);&#10;    &#10;    if (result.rows.length === 0) {&#10;      return res.status(404).json({ error: 'Utente non trovato' });&#10;    }&#10;    &#10;    res.json(result.rows[0]);&#10;  } catch (err) {&#10;    console.error('Error fetching user:', err);&#10;    res.status(500).json({ error: 'Errore nel recupero dell\'utente' });&#10;  }&#10;});&#10;&#10;// Aggiorna profilo utente&#10;router.put('/:id', async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { first_name, last_name, email, phone } = req.body;&#10;&#10;    const query = `&#10;      UPDATE users &#10;      SET first_name = $1, last_name = $2, email = $3, phone = $4, updated_at = CURRENT_TIMESTAMP&#10;      WHERE id = $5 &#10;      RETURNING id, first_name, last_name, email, phone, updated_at&#10;    `;&#10;    &#10;    const values = [first_name, last_name, email, phone, id];&#10;    const result = await pool.query(query, values);&#10;    &#10;    if (result.rows.length === 0) {&#10;      return res.status(404).json({ error: 'Utente non trovato' });&#10;    }&#10;    &#10;    res.json({ &#10;      message: 'Profilo aggiornato con successo', &#10;      user: result.rows[0] &#10;    });&#10;  } catch (err: any) {&#10;    console.error('Error updating user:', err);&#10;    if (err.code === '23505') { // Violazione vincolo univoco&#10;      res.status(400).json({ error: 'Email già esistente' });&#10;    } else {&#10;      res.status(400).json({ error: 'Errore nell\'aggiornamento del profilo' });&#10;    }&#10;  }&#10;});&#10;&#10;// Elimina utente&#10;router.delete('/:id', async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    &#10;    // Controlla se ci sono prenotazioni associate&#10;    const bookingsCheck = await pool.query(&#10;      'SELECT COUNT(*) as count FROM bookings WHERE user_id = $1',&#10;      [id]&#10;    );&#10;    &#10;    if (parseInt(bookingsCheck.rows[0].count) &gt; 0) {&#10;      return res.status(400).json({ &#10;        error: 'Impossibile eliminare l\'utente: esistono prenotazioni associate' &#10;      });&#10;    }&#10;    &#10;    const result = await pool.query('DELETE FROM users WHERE id = $1 RETURNING *', [id]);&#10;    &#10;    if (result.rows.length === 0) {&#10;      return res.status(404).json({ error: 'Utente non trovato' });&#10;    }&#10;    &#10;    res.json({ &#10;      message: 'Utente eliminato con successo', &#10;      user: result.rows[0] &#10;    });&#10;  } catch (err) {&#10;    console.error('Error deleting user:', err);&#10;    res.status(500).json({ error: 'Errore nell\'eliminazione dell\'utente' });&#10;  }&#10;});&#10;&#10;export default router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/app/components/airline-login.component.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/app/components/airline-login.component.ts" />
              <option name="originalContent" value="import { Component } from '@angular/core';&#10;import { CommonModule } from '@angular/common';&#10;import { FormsModule } from '@angular/forms';&#10;import { Router } from '@angular/router';&#10;import { HttpClient } from '@angular/common/http';&#10;&#10;@Component({&#10;  selector: 'app-airline-login',&#10;  standalone: true,&#10;  imports: [CommonModule, FormsModule],&#10;  template: `&#10;    &lt;div class=&quot;airline-login-container&quot;&gt;&#10;      &lt;div class=&quot;login-form&quot;&gt;&#10;        &lt;h2&gt; Accesso Compagnie Aeree&lt;/h2&gt;&#10;        &lt;p class=&quot;subtitle&quot;&gt;Accedi per gestire i voli della tua compagnia&lt;/p&gt;&#10;        &#10;        &lt;form (ngSubmit)=&quot;onLogin()&quot; #loginForm=&quot;ngForm&quot;&gt;&#10;          &lt;div class=&quot;form-group&quot;&gt;&#10;            &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&#10;            &lt;input &#10;              type=&quot;email&quot; &#10;              id=&quot;email&quot; &#10;              name=&quot;email&quot; &#10;              [(ngModel)]=&quot;email&quot; &#10;              required &#10;              placeholder=&quot;Es: admin@alitalia.com&quot;&#10;            &gt;&#10;          &lt;/div&gt;&#10;          &#10;          &lt;div class=&quot;form-group&quot;&gt;&#10;            &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;&#10;            &lt;input &#10;              type=&quot;password&quot; &#10;              id=&quot;password&quot; &#10;              name=&quot;password&quot; &#10;              [(ngModel)]=&quot;password&quot; &#10;              required &#10;              placeholder=&quot;Inserisci la password&quot;&#10;            &gt;&#10;          &lt;/div&gt;&#10;          &#10;          &lt;div class=&quot;error-message&quot; *ngIf=&quot;errorMessage&quot;&gt;&#10;            {{ errorMessage }}&#10;          &lt;/div&gt;&#10;          &#10;          &lt;button type=&quot;submit&quot; [disabled]=&quot;isLoading&quot; class=&quot;login-btn&quot;&gt;&#10;            &lt;span *ngIf=&quot;!isLoading&quot;&gt;Accedi&lt;/span&gt;&#10;            &lt;span *ngIf=&quot;isLoading&quot;&gt;Accesso in corso...&lt;/span&gt;&#10;          &lt;/button&gt;&#10;        &lt;/form&gt;&#10;        &#10;        &lt;div class=&quot;demo-section&quot;&gt;&#10;          &lt;h3&gt; Account Demo Disponibili&lt;/h3&gt;&#10;          &lt;div class=&quot;demo-accounts&quot;&gt;&#10;            &lt;div class=&quot;demo-card&quot; *ngFor=&quot;let airline of demoAirlines&quot; (click)=&quot;quickLogin(airline)&quot;&gt;&#10;              &lt;h4&gt;{{ airline.name }}&lt;/h4&gt;&#10;              &lt;p&gt;Email: {{ airline.email }}&lt;/p&gt;&#10;              &lt;p&gt;Password: {{ airline.password }}&lt;/p&gt;&#10;              &lt;small&gt;Clicca per accesso rapido&lt;/small&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        &#10;        &lt;div class=&quot;back-link&quot;&gt;&#10;          &lt;a routerLink=&quot;/flights&quot;&gt;← Torna alla visualizzazione voli&lt;/a&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  `,&#10;  styles: [`&#10;    .airline-login-container {&#10;      min-height: 100vh;&#10;      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);&#10;      display: flex;&#10;      align-items: center;&#10;      justify-content: center;&#10;      padding: 20px;&#10;      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;&#10;    }&#10;&#10;    .login-form {&#10;      background: white;&#10;      border-radius: 20px;&#10;      padding: 40px;&#10;      box-shadow: 0 20px 40px rgba(0,0,0,0.1);&#10;      max-width: 500px;&#10;      width: 100%;&#10;    }&#10;&#10;    h2 {&#10;      text-align: center;&#10;      color: #333;&#10;      margin-bottom: 10px;&#10;      font-size: 2rem;&#10;    }&#10;&#10;    .subtitle {&#10;      text-align: center;&#10;      color: #666;&#10;      margin-bottom: 30px;&#10;    }&#10;&#10;    .form-group {&#10;      margin-bottom: 20px;&#10;    }&#10;&#10;    label {&#10;      display: block;&#10;      margin-bottom: 8px;&#10;      color: #333;&#10;      font-weight: 500;&#10;    }&#10;&#10;    input {&#10;      width: 100%;&#10;      padding: 12px 16px;&#10;      border: 2px solid #e1e5e9;&#10;      border-radius: 8px;&#10;      font-size: 16px;&#10;      transition: border-color 0.3s ease;&#10;      box-sizing: border-box;&#10;    }&#10;&#10;    input:focus {&#10;      outline: none;&#10;      border-color: #667eea;&#10;    }&#10;&#10;    .error-message {&#10;      background: #fee;&#10;      color: #c33;&#10;      padding: 10px;&#10;      border-radius: 5px;&#10;      margin-bottom: 15px;&#10;      border: 1px solid #fcc;&#10;    }&#10;&#10;    .login-btn {&#10;      width: 100%;&#10;      padding: 14px;&#10;      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);&#10;      color: white;&#10;      border: none;&#10;      border-radius: 8px;&#10;      font-size: 16px;&#10;      font-weight: 600;&#10;      cursor: pointer;&#10;      transition: transform 0.2s ease;&#10;    }&#10;&#10;    .login-btn:hover {&#10;      transform: translateY(-2px);&#10;    }&#10;&#10;    .login-btn:disabled {&#10;      opacity: 0.7;&#10;      cursor: not-allowed;&#10;      transform: none;&#10;    }&#10;&#10;    .demo-section {&#10;      margin-top: 40px;&#10;      padding-top: 30px;&#10;      border-top: 2px solid #f0f0f0;&#10;    }&#10;&#10;    .demo-section h3 {&#10;      color: #333;&#10;      margin-bottom: 20px;&#10;      text-align: center;&#10;    }&#10;&#10;    .demo-accounts {&#10;      display: grid;&#10;      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));&#10;      gap: 15px;&#10;    }&#10;&#10;    .demo-card {&#10;      background: #f8f9fa;&#10;      border: 2px solid #e9ecef;&#10;      border-radius: 10px;&#10;      padding: 15px;&#10;      cursor: pointer;&#10;      transition: all 0.3s ease;&#10;      text-align: center;&#10;    }&#10;&#10;    .demo-card:hover {&#10;      border-color: #667eea;&#10;      transform: translateY(-2px);&#10;      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);&#10;    }&#10;&#10;    .demo-card h4 {&#10;      margin: 0 0 10px 0;&#10;      color: #333;&#10;    }&#10;&#10;    .demo-card p {&#10;      margin: 5px 0;&#10;      font-size: 0.9rem;&#10;      color: #666;&#10;    }&#10;&#10;    .demo-card small {&#10;      color: #999;&#10;      font-style: italic;&#10;    }&#10;&#10;    .back-link {&#10;      text-align: center;&#10;      margin-top: 30px;&#10;    }&#10;&#10;    .back-link a {&#10;      color: #667eea;&#10;      text-decoration: none;&#10;      font-weight: 500;&#10;    }&#10;&#10;    .back-link a:hover {&#10;      text-decoration: underline;&#10;    }&#10;&#10;    @media (max-width: 768px) {&#10;      .login-form {&#10;        padding: 20px;&#10;        margin: 10px;&#10;      }&#10;      &#10;      .demo-accounts {&#10;        grid-template-columns: 1fr;&#10;      }&#10;    }&#10;  `]&#10;})&#10;export class AirlineLoginComponent {&#10;  email = '';&#10;  password = '';&#10;  errorMessage = '';&#10;  isLoading = false;&#10;&#10;  demoAirlines = [&#10;    { name: 'Alitalia', email: 'admin@alitalia.com', password: 'alitalia123' },&#10;    { name: 'Lufthansa', email: 'admin@lufthansa.com', password: 'lufthansa123' },&#10;    { name: 'Air France', email: 'admin@airfrance.com', password: 'airfrance123' },&#10;    { name: 'Emirates', email: 'admin@emirates.com', password: 'emirates123' }&#10;  ];&#10;&#10;  constructor(&#10;    private http: HttpClient,&#10;    private router: Router&#10;  ) {}&#10;&#10;  onLogin() {&#10;    if (!this.email || !this.password) {&#10;      this.errorMessage = 'Inserisci email e password';&#10;      return;&#10;    }&#10;&#10;    this.isLoading = true;&#10;    this.errorMessage = '';&#10;&#10;    const loginData = { email: this.email, password: this.password };&#10;&#10;    this.http.post&lt;any&gt;('http://localhost:3000/api/auth/airline/login', loginData).subscribe({&#10;      next: (response: any) =&gt; {&#10;        this.isLoading = false;&#10;        if (response.success) {&#10;          // Store token and user data&#10;          localStorage.setItem('token', response.token);&#10;          localStorage.setItem('user', JSON.stringify(response.user));&#10;          console.log('Login successful:', response);&#10;          this.router.navigate(['/flight-admin']);&#10;        } else {&#10;          this.errorMessage = response.message || 'Errore durante il login';&#10;        }&#10;      },&#10;      error: (error: any) =&gt; {&#10;        this.isLoading = false;&#10;        this.errorMessage = 'Errore di connessione al server';&#10;        console.error('Login error:', error);&#10;      }&#10;    });&#10;  }&#10;&#10;  quickLogin(airline: any) {&#10;    this.email = airline.email;&#10;    this.password = airline.password;&#10;    this.onLogin();&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Component } from '@angular/core';&#13;&#10;import { CommonModule } from '@angular/common';&#13;&#10;import { FormsModule } from '@angular/forms';&#13;&#10;import { Router } from '@angular/router';&#13;&#10;import { HttpClient } from '@angular/common/http';&#13;&#10;&#13;&#10;@Component({&#13;&#10;  selector: 'app-airline-login',&#13;&#10;  standalone: true,&#13;&#10;  imports: [CommonModule, FormsModule],&#13;&#10;  template: `&#13;&#10;    &lt;div class=&quot;airline-login-container&quot;&gt;&#13;&#10;      &lt;div class=&quot;login-form&quot;&gt;&#13;&#10;        &lt;h2&gt; Accesso Compagnie Aeree&lt;/h2&gt;&#13;&#10;        &lt;p class=&quot;subtitle&quot;&gt;Accedi per gestire i voli della tua compagnia&lt;/p&gt;&#13;&#10;        &#13;&#10;        &lt;form (ngSubmit)=&quot;onLogin()&quot; #loginForm=&quot;ngForm&quot;&gt;&#13;&#10;          &lt;div class=&quot;form-group&quot;&gt;&#13;&#10;            &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&#13;&#10;            &lt;input &#13;&#10;              type=&quot;email&quot; &#13;&#10;              id=&quot;email&quot; &#13;&#10;              name=&quot;email&quot; &#13;&#10;              [(ngModel)]=&quot;email&quot; &#13;&#10;              required &#13;&#10;              placeholder=&quot;Es: admin@alitalia.com&quot;&#13;&#10;            &gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;          &#13;&#10;          &lt;div class=&quot;form-group&quot;&gt;&#13;&#10;            &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;&#13;&#10;            &lt;input &#13;&#10;              type=&quot;password&quot; &#13;&#10;              id=&quot;password&quot; &#13;&#10;              name=&quot;password&quot; &#13;&#10;              [(ngModel)]=&quot;password&quot; &#13;&#10;              required &#13;&#10;              placeholder=&quot;Inserisci la password&quot;&#13;&#10;            &gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;          &#13;&#10;          &lt;div class=&quot;error-message&quot; *ngIf=&quot;errorMessage&quot;&gt;&#13;&#10;            {{ errorMessage }}&#13;&#10;          &lt;/div&gt;&#13;&#10;          &#13;&#10;          &lt;button type=&quot;submit&quot; [disabled]=&quot;isLoading&quot; class=&quot;login-btn&quot;&gt;&#13;&#10;            &lt;span *ngIf=&quot;!isLoading&quot;&gt;Accedi&lt;/span&gt;&#13;&#10;            &lt;span *ngIf=&quot;isLoading&quot;&gt;Accesso in corso...&lt;/span&gt;&#13;&#10;          &lt;/button&gt;&#13;&#10;        &lt;/form&gt;&#13;&#10;        &#13;&#10;        &lt;div class=&quot;demo-section&quot;&gt;&#13;&#10;          &lt;h3&gt; Account Demo Disponibili&lt;/h3&gt;&#13;&#10;          &lt;div class=&quot;demo-accounts&quot;&gt;&#13;&#10;            &lt;div class=&quot;demo-card&quot; *ngFor=&quot;let airline of demoAirlines&quot; (click)=&quot;quickLogin(airline)&quot;&gt;&#13;&#10;              &lt;h4&gt;{{ airline.name }}&lt;/h4&gt;&#13;&#10;              &lt;p&gt;Email: {{ airline.email }}&lt;/p&gt;&#13;&#10;              &lt;p&gt;Password: {{ airline.password }}&lt;/p&gt;&#13;&#10;              &lt;small&gt;Clicca per accesso rapido&lt;/small&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;        &#13;&#10;        &lt;div class=&quot;back-link&quot;&gt;&#13;&#10;          &lt;a routerLink=&quot;/flights&quot;&gt;← Torna alla visualizzazione voli&lt;/a&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  `,&#13;&#10;  styles: [`&#13;&#10;    .airline-login-container {&#13;&#10;      min-height: 100vh;&#13;&#10;      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);&#13;&#10;      display: flex;&#13;&#10;      align-items: center;&#13;&#10;      justify-content: center;&#13;&#10;      padding: 20px;&#13;&#10;      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;&#13;&#10;    }&#13;&#10;&#13;&#10;    .login-form {&#13;&#10;      background: white;&#13;&#10;      border-radius: 20px;&#13;&#10;      padding: 40px;&#13;&#10;      box-shadow: 0 20px 40px rgba(0,0,0,0.1);&#13;&#10;      max-width: 500px;&#13;&#10;      width: 100%;&#13;&#10;    }&#13;&#10;&#13;&#10;    h2 {&#13;&#10;      text-align: center;&#13;&#10;      color: #333;&#13;&#10;      margin-bottom: 10px;&#13;&#10;      font-size: 2rem;&#13;&#10;    }&#13;&#10;&#13;&#10;    .subtitle {&#13;&#10;      text-align: center;&#13;&#10;      color: #666;&#13;&#10;      margin-bottom: 30px;&#13;&#10;    }&#13;&#10;&#13;&#10;    .form-group {&#13;&#10;      margin-bottom: 20px;&#13;&#10;    }&#13;&#10;&#13;&#10;    label {&#13;&#10;      display: block;&#13;&#10;      margin-bottom: 8px;&#13;&#10;      color: #333;&#13;&#10;      font-weight: 500;&#13;&#10;    }&#13;&#10;&#13;&#10;    input {&#13;&#10;      width: 100%;&#13;&#10;      padding: 12px 16px;&#13;&#10;      border: 2px solid #e1e5e9;&#13;&#10;      border-radius: 8px;&#13;&#10;      font-size: 16px;&#13;&#10;      transition: border-color 0.3s ease;&#13;&#10;      box-sizing: border-box;&#13;&#10;    }&#13;&#10;&#13;&#10;    input:focus {&#13;&#10;      outline: none;&#13;&#10;      border-color: #667eea;&#13;&#10;    }&#13;&#10;&#13;&#10;    .error-message {&#13;&#10;      background: #fee;&#13;&#10;      color: #c33;&#13;&#10;      padding: 10px;&#13;&#10;      border-radius: 5px;&#13;&#10;      margin-bottom: 15px;&#13;&#10;      border: 1px solid #fcc;&#13;&#10;    }&#13;&#10;&#13;&#10;    .login-btn {&#13;&#10;      width: 100%;&#13;&#10;      padding: 14px;&#13;&#10;      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);&#13;&#10;      color: white;&#13;&#10;      border: none;&#13;&#10;      border-radius: 8px;&#13;&#10;      font-size: 16px;&#13;&#10;      font-weight: 600;&#13;&#10;      cursor: pointer;&#13;&#10;      transition: transform 0.2s ease;&#13;&#10;    }&#13;&#10;&#13;&#10;    .login-btn:hover {&#13;&#10;      transform: translateY(-2px);&#13;&#10;    }&#13;&#10;&#13;&#10;    .login-btn:disabled {&#13;&#10;      opacity: 0.7;&#13;&#10;      cursor: not-allowed;&#13;&#10;      transform: none;&#13;&#10;    }&#13;&#10;&#13;&#10;    .demo-section {&#13;&#10;      margin-top: 40px;&#13;&#10;      padding-top: 30px;&#13;&#10;      border-top: 2px solid #f0f0f0;&#13;&#10;    }&#13;&#10;&#13;&#10;    .demo-section h3 {&#13;&#10;      color: #333;&#13;&#10;      margin-bottom: 20px;&#13;&#10;      text-align: center;&#13;&#10;    }&#13;&#10;&#13;&#10;    .demo-accounts {&#13;&#10;      display: grid;&#13;&#10;      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));&#13;&#10;      gap: 15px;&#13;&#10;    }&#13;&#10;&#13;&#10;    .demo-card {&#13;&#10;      background: #f8f9fa;&#13;&#10;      border: 2px solid #e9ecef;&#13;&#10;      border-radius: 10px;&#13;&#10;      padding: 15px;&#13;&#10;      cursor: pointer;&#13;&#10;      transition: all 0.3s ease;&#13;&#10;      text-align: center;&#13;&#10;    }&#13;&#10;&#13;&#10;    .demo-card:hover {&#13;&#10;      border-color: #667eea;&#13;&#10;      transform: translateY(-2px);&#13;&#10;      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);&#13;&#10;    }&#13;&#10;&#13;&#10;    .demo-card h4 {&#13;&#10;      margin: 0 0 10px 0;&#13;&#10;      color: #333;&#13;&#10;    }&#13;&#10;&#13;&#10;    .demo-card p {&#13;&#10;      margin: 5px 0;&#13;&#10;      font-size: 0.9rem;&#13;&#10;      color: #666;&#13;&#10;    }&#13;&#10;&#13;&#10;    .demo-card small {&#13;&#10;      color: #999;&#13;&#10;      font-style: italic;&#13;&#10;    }&#13;&#10;&#13;&#10;    .back-link {&#13;&#10;      text-align: center;&#13;&#10;      margin-top: 30px;&#13;&#10;    }&#13;&#10;&#13;&#10;    .back-link a {&#13;&#10;      color: #667eea;&#13;&#10;      text-decoration: none;&#13;&#10;      font-weight: 500;&#13;&#10;    }&#13;&#10;&#13;&#10;    .back-link a:hover {&#13;&#10;      text-decoration: underline;&#13;&#10;    }&#13;&#10;&#13;&#10;    @media (max-width: 768px) {&#13;&#10;      .login-form {&#13;&#10;        padding: 20px;&#13;&#10;        margin: 10px;&#13;&#10;      }&#13;&#10;      &#13;&#10;      .demo-accounts {&#13;&#10;        grid-template-columns: 1fr;&#13;&#10;      }&#13;&#10;    }&#13;&#10;  `]&#13;&#10;})&#13;&#10;export class AirlineLoginComponent {&#13;&#10;  email = '';&#13;&#10;  password = '';&#13;&#10;  errorMessage = '';&#13;&#10;  isLoading = false;&#13;&#10;&#13;&#10;  demoAirlines = [&#13;&#10;    { name: 'Alitalia', email: 'admin@alitalia.com', password: 'alitalia123' },&#13;&#10;    { name: 'Lufthansa', email: 'admin@lufthansa.com', password: 'lufthansa123' },&#13;&#10;    { name: 'Air France', email: 'admin@airfrance.com', password: 'airfrance123' },&#13;&#10;    { name: 'Emirates', email: 'admin@emirates.com', password: 'emirates123' }&#13;&#10;  ];&#13;&#10;&#13;&#10;  constructor(&#13;&#10;    private http: HttpClient,&#13;&#10;    private router: Router&#13;&#10;  ) {}&#13;&#10;&#13;&#10;  onLogin() {&#13;&#10;    if (!this.email || !this.password) {&#13;&#10;      this.errorMessage = 'Inserisci email e password';&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    this.isLoading = true;&#13;&#10;    this.errorMessage = '';&#13;&#10;&#13;&#10;    const loginData = { email: this.email, password: this.password };&#13;&#10;&#13;&#10;    // Usa l'endpoint corretto per il login unificato&#13;&#10;    this.http.post&lt;any&gt;('http://localhost:3000/api/users/login', loginData).subscribe({&#13;&#10;      next: (response: any) =&gt; {&#13;&#10;        this.isLoading = false;&#13;&#10;        &#13;&#10;        // Gestisci il caso di password temporanea (primo login compagnia)&#13;&#10;        if (response.requirePasswordChange) {&#13;&#10;          alert('Password temporanea rilevata. Devi cambiare la password al primo login.');&#13;&#10;          // Qui potresti reindirizzare a una pagina di cambio password&#13;&#10;          localStorage.setItem('tempToken', response.token);&#13;&#10;          this.router.navigate(['/change-password']);&#13;&#10;          return;&#13;&#10;        }&#13;&#10;        &#13;&#10;        // Login normale completato&#13;&#10;        if (response.token) {&#13;&#10;          localStorage.setItem('token', response.token);&#13;&#10;          localStorage.setItem('user', JSON.stringify(response.user));&#13;&#10;          console.log('Login successful:', response);&#13;&#10;          &#13;&#10;          // Reindirizza in base al ruolo&#13;&#10;          if (response.user.role === 'airline_admin') {&#13;&#10;            this.router.navigate(['/flight-admin']);&#13;&#10;          } else if (response.user.role === 'admin') {&#13;&#10;            this.router.navigate(['/admin-dashboard']);&#13;&#10;          } else {&#13;&#10;            this.router.navigate(['/flights']);&#13;&#10;          }&#13;&#10;        } else {&#13;&#10;          this.errorMessage = response.message || 'Errore durante il login';&#13;&#10;        }&#13;&#10;      },&#13;&#10;      error: (error: any) =&gt; {&#13;&#10;        this.isLoading = false;&#13;&#10;        &#13;&#10;        if (error.status === 401) {&#13;&#10;          this.errorMessage = 'Credenziali non valide';&#13;&#10;        } else if (error.status === 0) {&#13;&#10;          this.errorMessage = 'Errore di connessione al server';&#13;&#10;        } else {&#13;&#10;          this.errorMessage = error.error?.error || 'Errore durante il login';&#13;&#10;        }&#13;&#10;        &#13;&#10;        console.error('Login error:', error);&#13;&#10;      }&#13;&#10;    });&#13;&#10;  }&#13;&#10;&#13;&#10;  quickLogin(airline: any) {&#13;&#10;    this.email = airline.email;&#13;&#10;    this.password = airline.password;&#13;&#10;    this.onLogin();&#13;&#10;  }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/test-system.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/test-system.ps1" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/test-system.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/test-system.sh" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test-quick.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test-quick.ps1" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>